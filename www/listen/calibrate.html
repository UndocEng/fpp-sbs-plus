<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BT Delay Calibration</title>
  <style>
    :root{
      --bg:#0f1115;
      --card:#171a21;
      --ink:#e9eef7;
      --muted:#9aa6b2;
      --accent:#D4A030;
      --bad:#ff4d4d;
      --ok:#4dff88;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink); }
    .wrap{ max-width:720px; margin:0 auto; padding:18px; }
    .header{ text-align:center; margin:10px 0 18px; }
    .header img{ width:86px; height:86px; border-radius:18px; box-shadow:0 8px 28px rgba(0,0,0,.35); }
    h1{ margin:12px 0 6px; font-size:28px; letter-spacing:.3px; color:var(--accent); }
    .sub{ margin:0; color:var(--muted); font-size:14px; }
    .card{
      background:var(--card); border:1px solid rgba(255,255,255,.06);
      border-radius:16px; padding:16px; margin-top:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .section-title{ margin:0 0 10px; font-size:16px; color:var(--accent); }
    button{
      font-size:16px; padding:12px 16px; border-radius:12px;
      border:2px solid var(--accent); background:#11141a; color:var(--ink);
      cursor:pointer; width:100%;
    }
    button:active{ transform:scale(.99); }
    button:disabled{ opacity:.5; cursor:default; }
    .row{ display:flex; gap:10px; margin-top:10px; }
    .row button{ width:50%; }
    .small{ margin-top:12px; font-size:12px; color:var(--muted); line-height:1.4; }
    .footer{ margin-top:14px; text-align:center; font-size:12px; color:var(--muted); opacity:.85; }
    select, input[type="number"], input[type="text"]{
      width:100%; font-size:16px; padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); color:var(--ink);
    }
    input[type="range"]{ width:100%; margin:8px 0; accent-color:var(--accent); }
    .field-group{ margin-top:14px; }
    .field-group p{ margin:0 0 6px; font-size:14px; color:var(--muted); }
    .status-msg{ margin-top:8px; font-size:12px; padding:8px; border-radius:8px; display:none; }
    .status-msg.success{ display:block; background:rgba(77,255,136,.15); color:var(--ok); }
    .status-msg.error{ display:block; background:rgba(255,77,77,.15); color:var(--bad); }
    .box{ margin-top:8px; padding:12px; border:1px solid rgba(255,255,255,.06); border-radius:12px; background:rgba(0,0,0,.14); font-size:13px; color:var(--muted); }
    .box b{ color:var(--ink); opacity:.8; }
    .hidden{ display:none; }
    .delay-display{
      text-align:center; font-size:48px; font-weight:700; color:var(--accent);
      margin:8px 0; line-height:1;
    }
    .delay-unit{ font-size:16px; color:var(--muted); font-weight:400; }
    .profile-row{ display:flex; gap:8px; align-items:center; margin-top:10px; }
    .profile-row input{ flex:1; }
    .profile-row button{ width:auto; padding:10px 16px; font-size:14px; }
    .btn-sm{ font-size:14px; padding:10px 14px; margin-top:10px; width:auto; display:inline-block; }
    .flash-indicator{
      width:24px; height:24px; border-radius:50%; background:#333; display:inline-block;
      vertical-align:middle; margin-left:8px; transition: background 0.05s;
    }
    .flash-indicator.on{ background:var(--ok); box-shadow:0 0 12px var(--ok); }
  </style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <img src="logo.png" alt="Undocumented Engineer" />
    <h1>BT Delay Calibration</h1>
    <p class="sub">Sync your Bluetooth speaker to the lights</p>
    <p class="sub" style="margin-top:8px;">
      <a href="admin.html" style="color:var(--accent);text-decoration:none;">&#8592; Back to Admin</a>
    </p>
  </div>

  <!-- Card 1: Test Sequence -->
  <div class="card">
    <h3 class="section-title">Test Sequence</h3>
    <div class="field-group" style="margin-top:0;">
      <p>Output Device</p>
      <select id="outputSelect">
        <option value="">Loading outputs...</option>
      </select>
    </div>
    <div class="field-group">
      <p>Flash Duration</p>
      <select id="flashFrames">
        <option value="2">2 frames (40ms)</option>
        <option value="5" selected>5 frames (100ms)</option>
        <option value="10">10 frames (200ms)</option>
      </select>
    </div>
    <button id="genBtn" style="margin-top:14px;">Generate Test Sequence</button>
    <div id="genStatus" class="status-msg"></div>
    <p class="small">Creates a 15-second FSEQ that flashes the selected output every 1 second.
      Only <b>active</b> outputs from your FPP channel configuration are shown.</p>
  </div>

  <!-- Card 2: Calibration Runner -->
  <div class="card">
    <h3 class="section-title">Calibrate <span class="flash-indicator" id="flashDot"></span></h3>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn">Stop</button>
    </div>

    <div style="margin-top:16px;">
      <div class="delay-display"><span id="delayVal">0</span> <span class="delay-unit">ms</span></div>
      <input type="range" id="delaySlider" min="0" max="500" step="5" value="0" />
      <div style="display:flex;justify-content:space-between;font-size:12px;color:var(--muted);">
        <span>0 ms</span><span>250 ms</span><span>500 ms</span>
      </div>
    </div>

    <p class="small">
      <b>How to calibrate:</b> Start the test sequence, then adjust the slider until the audio click
      lines up with the light flash. Increase the value if you see the flash before hearing the click.
      The slider compensates for Bluetooth audio delay by playing the click earlier.
    </p>

    <div style="margin-top:12px;">
      <label style="font-size:13px;color:var(--muted);cursor:pointer;">
        <input type="checkbox" id="debugCheck" /> Show debug info
      </label>
    </div>

    <div id="debugBox" class="box hidden">
      <div><b>Transport:</b> <span id="wsState">-</span></div>
      <div><b>Clock Offset:</b> <span id="clockOffset">-</span> ms</div>
      <div><b>FPP State:</b> <span id="fppState">-</span></div>
      <div><b>FPP Position:</b> <span id="fppPos">-</span> ms</div>
      <div><b>Next Flash:</b> <span id="nextFlash">-</span></div>
      <div><b>Clicks Fired:</b> <span id="clickCount">0</span></div>
    </div>
  </div>

  <!-- Card 3: Profile Management -->
  <div class="card">
    <h3 class="section-title">Saved Profiles</h3>
    <div class="field-group" style="margin-top:0;">
      <p>Select Profile</p>
      <select id="profileSelect">
        <option value="">-- No Profile --</option>
      </select>
    </div>
    <div class="profile-row">
      <input type="text" id="profileName" placeholder="e.g. JBL Flip 6" maxlength="40" />
      <button id="saveProfile">Save</button>
      <button id="deleteProfile" style="border-color:var(--bad);color:var(--bad);">Delete</button>
    </div>
    <div id="profileStatus" class="status-msg"></div>
    <p class="small">Profiles are saved in your browser. Select one on the
      <a href="admin.html" style="color:var(--accent);">Admin</a> page to apply the delay during playback.</p>
  </div>

  <!-- Card 4: RPi Bluetooth (direct connection, USB adapter only) -->
  <div class="card" id="btCard" style="display:none;">
    <h3 class="section-title">RPi Bluetooth Speaker</h3>
    <p style="font-size:13px;color:var(--muted);margin:0 0 10px;">
      Connect a BT speaker directly to the Raspberry Pi via USB Bluetooth adapter.
    </p>
    <div id="btStatusLine" style="font-size:13px;color:var(--muted);margin-bottom:8px;">Checking...</div>
    <div id="btVolumeWrap" style="display:none;margin-bottom:12px;">
      <p style="margin:0 0 6px;font-size:14px;color:var(--muted);">Volume</p>
      <div style="display:flex;align-items:center;gap:10px;">
        <input type="range" id="btVolumeSlider" min="0" max="100" step="5" value="75" style="flex:1;">
        <span id="btVolumeVal" style="min-width:40px;text-align:right;font-size:14px;">75%</span>
      </div>
    </div>
    <button id="btScanBtn">Scan for Devices</button>
    <div id="btDevices" style="margin-top:10px;"></div>
    <div id="btStatus" class="status-msg"></div>
  </div>

  <div class="footer">
    <a href="admin.html" style="color:var(--accent);text-decoration:none;">&#8592; Back to Admin</a>
  </div>
</div>

<script>
(() => {
// =============================================================================
// BT DELAY CALIBRATION
// =============================================================================

const BT_PROFILES_KEY = 'fpp-bt-profiles';
const ADMIN_URL = 'admin.php';
const STATUS_URL = 'status.php';
const POLL_INTERVAL = 200;  // HTTP fallback poll interval
const TICK_INTERVAL = 50;   // Click scheduler tick interval

// --- DOM References ---
const outputSelect = document.getElementById('outputSelect');
const genBtn = document.getElementById('genBtn');
const genStatus = document.getElementById('genStatus');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const delaySlider = document.getElementById('delaySlider');
const delayVal = document.getElementById('delayVal');
const flashDot = document.getElementById('flashDot');
const debugCheck = document.getElementById('debugCheck');
const debugBox = document.getElementById('debugBox');
const profileSelect = document.getElementById('profileSelect');
const profileName = document.getElementById('profileName');
const saveProfileBtn = document.getElementById('saveProfile');
const deleteProfileBtn = document.getElementById('deleteProfile');
const profileStatus = document.getElementById('profileStatus');

// Debug elements
const wsStateEl = document.getElementById('wsState');
const clockOffsetEl = document.getElementById('clockOffset');
const fppStateEl = document.getElementById('fppState');
const fppPosEl = document.getElementById('fppPos');
const nextFlashEl = document.getElementById('nextFlash');
const clickCountEl = document.getElementById('clickCount');

// --- State ---
let ws = null;
let audioCtx = null;
let running = false;

// Clock offset (NTP-style)
let clockOffset = 0;
let clockOffsetValid = false;
let offsetHistory = [];
const OFFSET_HISTORY_SIZE = 5;

// Position tracking (interpolated between updates)
let fppPosMs = 0;       // Last known FPP position
let fppPosAt = 0;       // Date.now() when position was captured
let fppPlaying = false;  // Is FPP currently playing?

// Click scheduler
let scheduledFlashSec = -1;
let clickCount = 0;
let tickTimer = null;
let pollTimer = null;
let wsPingTimer = null;

// --- Helpers ---
function showStatus(el, msg, ok) {
  el.textContent = msg;
  el.className = 'status-msg ' + (ok ? 'success' : 'error');
  el.style.display = 'block';
  setTimeout(() => { el.style.display = 'none'; }, 5000);
}

function post(action, params) {
  const body = new URLSearchParams({ action, ...params });
  return fetch(ADMIN_URL, { method: 'POST', body }).then(r => r.json());
}

function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// =============================================================================
// CARD 1: Output Channel Selection + Sequence Generation
// =============================================================================

function loadOutputs() {
  post('get_channel_outputs', {}).then(res => {
    if (!res.success) {
      outputSelect.innerHTML = '<option value="">Failed to load outputs</option>';
      return;
    }
    const active = res.outputs.filter(o => o.active);
    const inactive = res.outputs.filter(o => !o.active);
    let html = '';

    if (active.length === 0 && inactive.length === 0) {
      html = '<option value="">No outputs configured in FPP</option>';
    } else if (active.length === 0) {
      html = '<option value="">No active outputs (enable outputs in FPP)</option>';
      inactive.forEach(o => {
        const end = o.startChannel + o.channelCount - 1;
        html += '<option value="' + o.startChannel + ':' + o.channelCount
          + '" style="color:#999;">' + escHtml(o.description)
          + ' (Ch ' + o.startChannel + '-' + end + ') [inactive]</option>';
      });
    } else {
      // Active outputs
      active.forEach(o => {
        const end = o.startChannel + o.channelCount - 1;
        html += '<option value="' + o.startChannel + ':' + o.channelCount + '">'
          + escHtml(o.description) + ' (Ch ' + o.startChannel + '-' + end + ')</option>';
      });
      // "All Active" option
      if (active.length > 1) {
        const minCh = Math.min(...active.map(o => o.startChannel));
        const maxCh = Math.max(...active.map(o => o.startChannel + o.channelCount - 1));
        const totalCount = maxCh - minCh + 1;
        html += '<option value="' + minCh + ':' + totalCount
          + '">All Active Outputs (Ch ' + minCh + '-' + maxCh + ')</option>';
      }
    }
    outputSelect.innerHTML = html;
  }).catch(() => {
    outputSelect.innerHTML = '<option value="">Network error loading outputs</option>';
  });
}

genBtn.addEventListener('click', () => {
  const val = outputSelect.value;
  if (!val) {
    showStatus(genStatus, 'Select an output device first', false);
    return;
  }
  const parts = val.split(':');
  const startCh = parseInt(parts[0]);
  const chCount = parseInt(parts[1]);

  genBtn.disabled = true;
  genBtn.textContent = 'Generating...';
  post('generate_cal_fseq', {
    start_ch: startCh,
    ch_count: chCount,
    flash_frames: document.getElementById('flashFrames').value
  }).then(res => {
    genBtn.disabled = false;
    genBtn.textContent = 'Generate Test Sequence';
    if (res.success) {
      showStatus(genStatus, 'Sequence generated: ' + res.file + ' (' + res.channels + ', ' + res.duration + ')', true);
    } else {
      showStatus(genStatus, res.error || 'Generation failed', false);
    }
  }).catch(() => {
    genBtn.disabled = false;
    genBtn.textContent = 'Generate Test Sequence';
    showStatus(genStatus, 'Network error', false);
  });
});

// =============================================================================
// CARD 2: Calibration Runner
// =============================================================================

delaySlider.addEventListener('input', () => {
  delayVal.textContent = delaySlider.value;
});

debugCheck.addEventListener('change', () => {
  debugBox.classList.toggle('hidden', !debugCheck.checked);
});

// --- Web Audio Click ---
function ensureAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playClick() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.value = 1000;
  gain.gain.setValueAtTime(0.6, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(now);
  osc.stop(now + 0.02);
}

// --- Clock Offset (NTP-style) ---
function updateClockOffset(serverMs, clientSendMs, rtt) {
  const offset = serverMs - clientSendMs - Math.round(rtt / 2);
  offsetHistory.push(offset);
  if (offsetHistory.length > OFFSET_HISTORY_SIZE) offsetHistory.shift();
  // Use median for robustness against outliers
  const sorted = [...offsetHistory].sort((a, b) => a - b);
  clockOffset = sorted[Math.floor(sorted.length / 2)];
  clockOffsetValid = offsetHistory.length >= 2;
  clockOffsetEl.textContent = Math.round(clockOffset);
}

// --- Position Tracking ---
function getCurrentPosMs() {
  if (!fppPlaying) return fppPosMs;
  return fppPosMs + (Date.now() - fppPosAt);
}

function updatePosition(msg) {
  const now = Date.now();
  const serverMs = Number(msg.server_ms || 0);
  const rawPosMs = Number(msg.pos_ms || 0);

  // Compute elapsed time since server captured this position
  let elapsed = 0;
  if (clockOffsetValid && serverMs > 0) {
    elapsed = (now + clockOffset) - serverMs;
  } else if (serverMs > 0) {
    elapsed = now - serverMs;
  }
  if (elapsed < 0) elapsed = 0;
  if (elapsed > 2000) elapsed = 0; // stale, ignore

  fppPosMs = rawPosMs + elapsed;
  fppPosAt = now;
  fppPlaying = (msg.state === 'play');

  // Update debug display
  fppStateEl.textContent = msg.state || '-';
  fppPosEl.textContent = Math.round(fppPosMs);
}

// --- Click Scheduler (tick-based, precise setTimeout) ---
function startTick() {
  if (tickTimer) return;
  tickTimer = setInterval(tick, TICK_INTERVAL);
}

function stopTick() {
  if (tickTimer) { clearInterval(tickTimer); tickTimer = null; }
  scheduledFlashSec = -1;
}

function tick() {
  if (!running || !fppPlaying) return;
  const posMs = getCurrentPosMs();
  if (posMs < 0) return;

  const currentSec = Math.floor(posMs / 1000);
  const nextSec = currentSec + 1;
  const nextFlashMs = nextSec * 1000;
  const msUntilFlash = nextFlashMs - posMs;

  // Update debug
  nextFlashEl.textContent = nextFlashMs + 'ms (in ' + Math.round(msUntilFlash) + 'ms)';

  // Schedule click for next second boundary (if not already scheduled)
  if (nextSec > scheduledFlashSec && msUntilFlash > 0 && msUntilFlash < 800) {
    scheduledFlashSec = nextSec;
    const sliderMs = parseInt(delaySlider.value) || 0;
    // Fire click early by sliderMs to compensate for BT latency
    const clickDelay = Math.max(0, msUntilFlash - sliderMs);
    setTimeout(() => { fireClick(); }, clickDelay);
  }

  // Also check if we just crossed a boundary (first tick after start)
  if (currentSec >= 0 && currentSec > scheduledFlashSec) {
    const fractMs = posMs - (currentSec * 1000);
    if (fractMs < 100) {
      scheduledFlashSec = currentSec;
      fireClick();
    }
  }
}

function fireClick() {
  // Flash the dot indicator (represents the light flash)
  flashDot.classList.add('on');
  setTimeout(() => flashDot.classList.remove('on'), 120);

  // Play the audio click
  playClick();
  clickCount++;
  clickCountEl.textContent = clickCount;
}

// --- WebSocket Connection ---
function connectWS() {
  if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) return;
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  const url = proto + '://' + location.hostname + '/ws';
  try { ws = new WebSocket(url); } catch (e) { startHttpPoll(); return; }
  wsStateEl.textContent = 'connecting...';

  ws.onopen = () => {
    wsStateEl.textContent = 'WebSocket connected';
    stopHttpPoll();
    offsetHistory = [];
    clockOffsetValid = false;
    // Burst pings for fast clock calibration
    sendPing();
    setTimeout(sendPing, 200);
    setTimeout(sendPing, 400);
    setTimeout(sendPing, 600);
    setTimeout(sendPing, 800);
    if (wsPingTimer) clearInterval(wsPingTimer);
    wsPingTimer = setInterval(sendPing, 1000);
  };

  ws.onmessage = (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      if (msg.type === 'pong') {
        const now = Date.now();
        const rtt = now - msg.client_ts;
        if (rtt > 0 && rtt < 500) {
          updateClockOffset(msg.server_ts, msg.client_ts, rtt);
        }
        return;
      }
      // FPP state broadcast
      if (msg.state !== undefined) {
        updatePosition(msg);
      }
    } catch (e) {}
  };

  ws.onclose = () => {
    wsStateEl.textContent = 'WS disconnected, HTTP fallback';
    if (wsPingTimer) { clearInterval(wsPingTimer); wsPingTimer = null; }
    startHttpPoll();
    if (running) setTimeout(connectWS, 2000);
  };

  ws.onerror = () => { ws.close(); };
}

function sendPing() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'ping', client_ts: Date.now() }));
  }
}

// --- HTTP Polling Fallback ---
function startHttpPoll() {
  if (pollTimer) return;
  pollTimer = setInterval(pollOnce, POLL_INTERVAL);
  pollOnce();
}

function stopHttpPoll() {
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
}

async function pollOnce() {
  const t0 = Date.now();
  try {
    const r = await fetch(STATUS_URL + '?ts=' + t0, { cache: 'no-store' });
    if (!r.ok) return;
    const msg = await r.json();
    const t1 = Date.now();
    const rtt = t1 - t0;
    if (msg.server_ms && rtt > 0 && rtt < 500) {
      updateClockOffset(msg.server_ms, t0, rtt);
    }
    if (msg.state !== undefined) {
      updatePosition(msg);
    }
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      wsStateEl.textContent = 'HTTP poll (' + rtt + 'ms)';
    }
  } catch (e) {}
}

// --- Start / Stop ---
startBtn.addEventListener('click', () => {
  ensureAudioCtx();
  running = true;
  scheduledFlashSec = -1;
  clickCount = 0;
  clickCountEl.textContent = '0';

  // Start the calibration sequence on FPP
  post('start_sequence', { sequence: '_bt_cal.fseq' }).then(res => {
    if (!res.success) {
      showStatus(genStatus, 'Start failed: ' + (res.error || 'Generate the test sequence first'), false);
    }
  }).catch(() => {});

  // Connect transports
  connectWS();
  startHttpPoll();

  // Start the click scheduler
  startTick();
});

stopBtn.addEventListener('click', () => {
  running = false;
  scheduledFlashSec = -1;
  fppPlaying = false;

  post('stop_playback', {}).catch(() => {});

  stopTick();
  stopHttpPoll();
  if (ws) { ws.close(); ws = null; }
  if (wsPingTimer) { clearInterval(wsPingTimer); wsPingTimer = null; }
  wsStateEl.textContent = '-';
  fppStateEl.textContent = '-';
  fppPosEl.textContent = '-';
  nextFlashEl.textContent = '-';
});

// =============================================================================
// CARD 3: Profile Management
// =============================================================================

function loadProfiles() {
  try {
    const raw = localStorage.getItem(BT_PROFILES_KEY);
    if (raw) return JSON.parse(raw);
  } catch (e) {}
  return { activeProfile: '', profiles: {} };
}

function saveProfiles(data) {
  try { localStorage.setItem(BT_PROFILES_KEY, JSON.stringify(data)); } catch (e) {}
}

function refreshProfileUI() {
  const data = loadProfiles();
  profileSelect.innerHTML = '<option value="">-- No Profile --</option>';
  Object.keys(data.profiles).sort().forEach(name => {
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name + ' (' + data.profiles[name].delayMs + 'ms)';
    profileSelect.appendChild(opt);
  });
  if (data.activeProfile && data.profiles[data.activeProfile]) {
    profileSelect.value = data.activeProfile;
    delaySlider.value = data.profiles[data.activeProfile].delayMs;
    delayVal.textContent = delaySlider.value;
  }
}

profileSelect.addEventListener('change', () => {
  const data = loadProfiles();
  const name = profileSelect.value;
  if (name && data.profiles[name]) {
    delaySlider.value = data.profiles[name].delayMs;
    delayVal.textContent = delaySlider.value;
    data.activeProfile = name;
  } else {
    data.activeProfile = '';
  }
  saveProfiles(data);
});

saveProfileBtn.addEventListener('click', () => {
  let name = profileName.value.trim();
  if (!name) name = profileSelect.value;
  if (!name) {
    showStatus(profileStatus, 'Enter a profile name', false);
    return;
  }
  const data = loadProfiles();
  const delayMs = parseInt(delaySlider.value) || 0;
  data.profiles[name] = { delayMs };
  data.activeProfile = name;
  saveProfiles(data);
  refreshProfileUI();
  profileName.value = '';
  showStatus(profileStatus, 'Saved "' + name + '" at ' + delayMs + 'ms', true);
});

deleteProfileBtn.addEventListener('click', () => {
  const name = profileSelect.value;
  if (!name) {
    showStatus(profileStatus, 'Select a profile to delete', false);
    return;
  }
  const data = loadProfiles();
  delete data.profiles[name];
  if (data.activeProfile === name) data.activeProfile = '';
  saveProfiles(data);
  refreshProfileUI();
  showStatus(profileStatus, 'Deleted "' + name + '"', true);
});

// =============================================================================
// CARD 4: RPi Bluetooth
// =============================================================================

const btCard = document.getElementById('btCard');
const btScanBtn = document.getElementById('btScanBtn');
const btDevices = document.getElementById('btDevices');
const btStatusEl = document.getElementById('btStatus');
const btStatusLine = document.getElementById('btStatusLine');
const btVolumeWrap = document.getElementById('btVolumeWrap');
const btVolumeSlider = document.getElementById('btVolumeSlider');
const btVolumeVal = document.getElementById('btVolumeVal');

let volTimeout = null;
btVolumeSlider.addEventListener('input', () => {
  btVolumeVal.textContent = btVolumeSlider.value + '%';
  clearTimeout(volTimeout);
  volTimeout = setTimeout(() => {
    post('bt_volume', { volume: btVolumeSlider.value });
  }, 150);
});

function refreshBTStatus() {
  post('bt_status', {}).then(res => {
    if (!res.success || !res.usb_adapter) {
      btCard.style.display = 'none';
      return;
    }
    btCard.style.display = '';
    if (!res.available) {
      btStatusLine.textContent = 'No Bluetooth adapter detected';
      btScanBtn.disabled = true;
      btVolumeWrap.style.display = 'none';
      return;
    }
    if (!res.powered) {
      btStatusLine.textContent = 'Bluetooth adapter off (will power on when scanning)';
      btVolumeWrap.style.display = 'none';
    } else if (res.count > 0) {
      const names = res.connected.map(d => d.name).join(', ');
      btStatusLine.innerHTML = '<span style="color:var(--ok);">Connected:</span> ' + escHtml(names);
      btVolumeWrap.style.display = 'block';
      if (res.volume !== null && res.volume !== undefined) {
        btVolumeSlider.value = res.volume;
        btVolumeVal.textContent = res.volume + '%';
      }
    } else {
      btStatusLine.textContent = 'Bluetooth on, no devices connected';
      btVolumeWrap.style.display = 'none';
    }

    if (res.connected && res.connected.length > 0) {
      let html = '';
      res.connected.forEach(d => {
        html += '<div style="display:flex;align-items:center;justify-content:space-between;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06);">'
          + '<span style="color:var(--ok);">' + escHtml(d.name) + '</span>'
          + '<button class="btn-sm" style="border-color:var(--bad);color:var(--bad);margin:0;padding:4px 10px;font-size:12px;" '
          + 'onclick="disconnectBT(\'' + escHtml(d.mac) + '\')">'
          + 'Disconnect</button></div>';
      });
      btDevices.innerHTML = html;
    }
  }).catch(() => {
    btCard.style.display = 'none';
  });
}

btScanBtn.addEventListener('click', () => {
  btScanBtn.disabled = true;
  btScanBtn.textContent = 'Scanning... (10s)';
  btDevices.innerHTML = '<div style="color:var(--muted);font-size:13px;">Scanning for nearby Bluetooth devices...</div>';

  post('bt_scan', {}).then(res => {
    btScanBtn.disabled = false;
    btScanBtn.textContent = 'Scan for Devices';
    if (!res.success) {
      showStatus(btStatusEl, res.error || 'Scan failed', false);
      return;
    }
    if (res.devices.length === 0) {
      btDevices.innerHTML = '<div style="color:var(--muted);font-size:13px;">No devices found. Make sure your speaker is in pairing mode.</div>';
      return;
    }
    let html = '';
    res.devices.forEach(d => {
      html += '<div style="display:flex;align-items:center;justify-content:space-between;padding:8px 0;border-bottom:1px solid rgba(255,255,255,.06);">'
        + '<div><b>' + escHtml(d.name) + '</b><br><span style="font-size:11px;color:var(--muted);">' + escHtml(d.mac) + '</span></div>'
        + '<div style="display:flex;gap:6px;">'
        + '<button class="btn-sm" style="margin:0;padding:4px 10px;font-size:12px;" '
        + 'onclick="pairBT(\'' + escHtml(d.mac) + '\')">Pair</button>'
        + '<button class="btn-sm" style="margin:0;padding:4px 10px;font-size:12px;" '
        + 'onclick="connectBT(\'' + escHtml(d.mac) + '\')">Connect</button>'
        + '</div></div>';
    });
    btDevices.innerHTML = html;
  }).catch(() => {
    btScanBtn.disabled = false;
    btScanBtn.textContent = 'Scan for Devices';
    showStatus(btStatusEl, 'Network error', false);
  });
});

window.pairBT = function(mac) {
  showStatus(btStatusEl, 'Pairing...', true);
  post('bt_pair', { mac }).then(res => {
    showStatus(btStatusEl, res.message || (res.success ? 'Paired' : 'Failed'), res.success);
    if (res.success) refreshBTStatus();
  }).catch(() => showStatus(btStatusEl, 'Network error', false));
};

window.connectBT = function(mac) {
  showStatus(btStatusEl, 'Connecting...', true);
  post('bt_connect', { mac }).then(res => {
    showStatus(btStatusEl, res.message || (res.success ? 'Connected' : 'Failed'), res.success);
    refreshBTStatus();
  }).catch(() => showStatus(btStatusEl, 'Network error', false));
};

window.disconnectBT = function(mac) {
  post('bt_disconnect', { mac }).then(res => {
    showStatus(btStatusEl, res.message || 'Disconnected', true);
    refreshBTStatus();
  }).catch(() => showStatus(btStatusEl, 'Network error', false));
};

// =============================================================================
// INIT
// =============================================================================

loadOutputs();
refreshProfileUI();
refreshBTStatus();

})();
</script>
</body>
</html>
