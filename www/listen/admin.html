<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Show Audio</title>
  <style>
    :root{
      --bg:#0f1115;
      --card:#171a21;
      --ink:#e9eef7;
      --muted:#9aa6b2;
      --accent:#D4A030;
      --bad:#ff4d4d;
      --ok:#4dff88;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink); }
    .wrap{ max-width:720px; margin:0 auto; padding:18px; }
    .header{ text-align:center; margin:10px 0 18px; }
    .header img{ width:86px; height:86px; border-radius:18px; box-shadow:0 8px 28px rgba(0,0,0,.35); }
    h1{ margin:12px 0 6px; font-size:34px; letter-spacing:.3px; color:var(--accent); }
    .sub{ margin:0; color:var(--muted); font-size:14px; }
    .card{
      background:var(--card); border:1px solid rgba(255,255,255,.06);
      border-radius:16px; padding:16px; margin-top:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .card:first-of-type{ margin-top:0; }
    .section-title{ margin:0 0 10px; font-size:16px; color:var(--accent); }
    button{
      font-size:16px; padding:12px 16px; border-radius:12px;
      border:2px solid var(--accent); background:#11141a; color:var(--ink);
      cursor:pointer; width:100%;
    }
    button:active{ transform:scale(.99); }
    button:disabled{ opacity:.5; cursor:default; }
    .row{ display:flex; gap:10px; margin-top:10px; }
    .row button{ width:50%; }
    .small{ margin-top:12px; font-size:12px; color:var(--muted); line-height:1.4; }
    .footer{ margin-top:14px; text-align:center; font-size:12px; color:var(--muted); opacity:.85; }
    audio{ width:100%; margin-top:12px; }
    select{
      width:100%; font-size:16px; padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); color:var(--ink);
      cursor:pointer;
    }
    select option, select optgroup{ background:#000; color:#fff; }
    input[type="text"],input[type="password"]{
      width:100%; font-size:16px; padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); color:var(--ink);
    }
    .btn-sm{ font-size:14px; padding:10px 14px; margin-top:10px; width:auto; display:inline-block; }
    .opts-toggle{ cursor:pointer; color:var(--accent); font-size:15px; padding:4px 0; user-select:none; }
    .opts-body{ display:none; margin-top:12px; }
    .opts-body.open{ display:block; }
    .field-group{ margin-top:14px; }
    .field-group p{ margin:0 0 6px; font-size:14px; color:var(--muted); }
    .status-msg{ margin-top:8px; font-size:12px; padding:8px; border-radius:8px; display:none; }
    .status-msg.success{ background:rgba(77,255,136,.15); color:var(--ok); }
    .status-msg.error{ background:rgba(255,77,77,.15); color:var(--bad); }
    /* Sync UI */
    .idle-msg{ text-align:center; margin-top:16px; padding:16px; border:1px solid rgba(255,255,255,.06); border-radius:12px; background:rgba(0,0,0,.14); color:var(--muted); font-size:15px; }
    .now-playing{ text-align:center; margin-top:14px; padding:12px; border:1px solid var(--accent); border-radius:12px; background:rgba(212,160,48,.08); font-size:16px; color:var(--accent); }
    .err{ color:var(--bad); font-weight:600; font-size:13px; margin-top:6px; }
    .debug-toggle{ margin-top:14px; font-size:13px; color:var(--muted); opacity:.6; }
    .debug-toggle label{ cursor:pointer; }
    .box{ margin-top:8px; padding:12px; border:1px solid rgba(255,255,255,.06); border-radius:12px; background:rgba(0,0,0,.14); font-size:13px; color:var(--muted); }
    .box b{ color:var(--ink); opacity:.8; }
    .hidden{ display:none; }
    .clock-warn{
      margin-top:16px; padding:14px; border-radius:12px;
      background:rgba(255,77,77,.12); border:1px solid var(--bad);
      text-align:center; font-size:14px; color:var(--ink);
    }
    .clock-warn b{ color:var(--bad); }
    .clock-warn .cw-btns{ margin-top:10px; display:flex; gap:10px; justify-content:center; }
    .clock-warn .cw-btns button{ width:auto; padding:8px 24px; font-size:14px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <a href="/plugin.php?plugin=SBSPlus&page=plugin.php" style="text-decoration:none;">
      <img src="logo.png" alt="Undocumented Engineer" />
    </a>
    <h1>Show Audio</h1>
    <p class="sub" id="ver">v...</p>
    <p class="sub">Keep this page open during the show.</p>
    <p class="sub" style="margin-top:8px;">
      <a href="/plugin.php?plugin=SBSPlus&page=plugin.php" style="color:var(--accent);text-decoration:none;">&#8592; SBS Dashboard</a>
      &nbsp;|&nbsp;
      <a href="/" style="color:var(--muted);text-decoration:none;">FPP Home</a>
    </p>
  </div>

  <!-- Playback Control -- always visible -->
  <div class="card">
    <h3 class="section-title">Playback</h3>
    <select id="seqSelect"><option value="">Loading...</option></select>
    <div class="row">
      <button id="startSeq">Start</button>
      <button id="stopSeq">Stop</button>
    </div>
    <div id="seqStatus" class="status-msg"></div>
  </div>

  <!-- Clock Warning -->
  <div id="clockWarn" class="clock-warn hidden">
    <b>&#9888; Pi clock is wrong</b>
    <div id="clockWarnMsg" style="margin-top:6px;color:var(--muted);font-size:13px;"></div>
    <div class="cw-btns">
      <button id="clockYes" style="border-color:var(--ok);color:var(--ok);">Yes, set clock</button>
      <button id="clockNo" style="border-color:var(--muted);color:var(--muted);">No</button>
    </div>
  </div>

  <!-- Sync Status -->
  <div class="card">
    <button id="enableBtn">Enable Audio</button>
    <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>
    <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing<div id="trackName" style="margin-top:4px;">-</div><div id="mediaFile" style="font-size:13px;color:var(--muted);margin-top:2px;"></div></div>

    <div class="err" id="fetchErr"></div>
    <div class="err" id="playErr"></div>

    <div class="debug-toggle">
      <label><input type="checkbox" id="debugCheck" /> Debug</label> &nbsp;
      <label><input type="checkbox" id="logCheck" /> Client Log</label> &nbsp;
      <label><input type="checkbox" id="serverLogCheck" /> Server Log</label>
    </div>

    <div id="debugBox" class="box hidden">
      <div><b>Transport:</b> <span id="transport">-</span></div>
      <div><b>RTT:</b> <span id="rtt">-</span> ms</div>
      <div><b>Clock Offset:</b> <span id="offset">-</span> ms</div>
      <div><b>Sequence:</b> <span id="seq">-</span></div>
      <div><b>State:</b> <span id="state">-</span></div>
      <div><b>Target:</b> <span id="target">-</span> ms</div>
      <div><b>Local:</b> <span id="local">-</span> ms</div>
      <div><b>Error:</b> <span id="err">-</span> ms</div>
      <div><b>PLL State:</b> <span id="pllState">idle</span></div>
      <div><b>Rate:</b> <span id="pllRate">1.000</span>x</div>
      <div><b>Avg Error (2s):</b> <span id="avgErr2s">-</span> ms</div>
      <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>
      <div><b>Effective Rate:</b> <span id="effRate">-</span></div>
      <div><b>Buffered:</b> <span id="buffered">-</span> s</div>
      <div><b>Last Correction:</b> <span id="lastCorrection">-</span></div>
      <div><b>Play Latency:</b> <span id="playLatency">0</span> ms</div>
      <div><b>BT Comp:</b> <span id="btDelay">0</span> ms</div>
    </div>

    <div id="logControls" class="hidden" style="margin-top:8px;text-align:right;">
      <span id="logStatus" style="font-size:11px;color:#f90;margin-right:8px;"></span>
      <button id="resumeLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--muted);display:none;">Resume Log</button>
      <button id="copyLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--muted);">Copy Log</button>
      <button id="clearLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--muted);">Clear Log</button>
    </div>
    <div id="logBox" class="box hidden" style="max-height:200px;overflow-y:auto;font-family:monospace;font-size:11px;white-space:pre-wrap;"></div>

    <audio id="audio" preload="auto" playsinline></audio>

    <div class="footer" id="verFooter"></div>
  </div>

  <!-- BT Speaker Delay Profiles -->
  <div class="card">
    <h3 class="section-title">BT Speaker Delay</h3>
    <div class="field-group" style="margin-top:0;">
      <p>Profile</p>
      <select id="btProfileSelect">
        <option value="">None</option>
      </select>
    </div>
    <div style="margin-top:8px;font-size:14px;">
      Active delay: <b id="btDelayDisplay">0</b> ms
      &nbsp;&middot;&nbsp;
      <a href="calibrate.html" style="color:var(--accent);font-size:13px;">Calibrate</a>
    </div>
  </div>

  <!-- Bottom navigation -->
  <div style="margin-top:16px;text-align:center;">
    <a href="/plugin.php?plugin=SBSPlus&page=plugin.php" style="display:inline-block;padding:10px 20px;border:2px solid var(--accent);border-radius:12px;color:var(--accent);text-decoration:none;font-size:15px;">
      &#9881; SBS Dashboard
    </a>
  </div>

</div>

<script>
(() => {
// =============================================================================
// FPP SBS Audio Sync - Adaptive PLL Audio Synchronization
// =============================================================================
// Ported from fpp-listener-sync v2.4.0
//
// Syncs HTML5 audio playback on audience phones to a Falcon Player (FPP)
// master clock. Uses WebSocket (primary) or HTTP polling (fallback) for
// transport, NTP-style clock offset estimation, and a 3-phase PLL
// (idle -> calibrating -> locked) with adaptive gain and log-compressed
// corrections. Converges in ~12-14 seconds with 5-25ms steady-state error.
// =============================================================================

// --- DOM References ---
const enableBtn=document.getElementById('enableBtn'),
audio=document.getElementById('audio'),
mediaFileEl=document.getElementById('mediaFile'),
idleMsg=document.getElementById('idleMsg'),
nowPlaying=document.getElementById('nowPlaying'),
trackName=document.getElementById('trackName'),
pollEl=document.getElementById('transport'),
fetchErrEl=document.getElementById('fetchErr'),
playErrEl=document.getElementById('playErr'),
seqEl=document.getElementById('seq'),
stateEl=document.getElementById('state'),
targetEl=document.getElementById('target'),
localEl=document.getElementById('local'),
errEl=document.getElementById('err'),
pllStateEl=document.getElementById('pllState'),
pllRateEl=document.getElementById('pllRate'),
avgErr2sEl=document.getElementById('avgErr2s'),
avgErrAllEl=document.getElementById('avgErrAll'),
effRateEl=document.getElementById('effRate'),
bufferedEl=document.getElementById('buffered'),
lastCorrectionEl=document.getElementById('lastCorrection'),
playLatencyEl=document.getElementById('playLatency'),
rttEl=document.getElementById('rtt'),
offsetEl=document.getElementById('offset'),
debugCheck=document.getElementById('debugCheck'),
debugBox=document.getElementById('debugBox'),
btDelayDebug=document.getElementById('btDelay');

// --- BT Speaker Delay Profiles ---
const BT_PROFILES_KEY='fpp-bt-profiles';
let btDelayMs=0;
try{
  const raw=localStorage.getItem(BT_PROFILES_KEY);
  if(raw){
    const d=JSON.parse(raw);
    if(d.activeProfile&&d.profiles&&d.profiles[d.activeProfile]){
      btDelayMs=Number(d.profiles[d.activeProfile].delayMs)||0;
    }
  }
}catch(e){}

const btProfileSelect=document.getElementById('btProfileSelect');
const btDelayDisplay=document.getElementById('btDelayDisplay');

function loadBTProfiles(){
  try{
    const raw=localStorage.getItem(BT_PROFILES_KEY);
    if(raw)return JSON.parse(raw);
  }catch(e){}
  return {activeProfile:'',profiles:{}};
}

function refreshBTProfileUI(){
  const data=loadBTProfiles();
  btProfileSelect.innerHTML='<option value="">None</option>';
  Object.keys(data.profiles).sort().forEach(name=>{
    const opt=document.createElement('option');
    opt.value=name;
    opt.textContent=name+' ('+data.profiles[name].delayMs+'ms)';
    btProfileSelect.appendChild(opt);
  });
  if(data.activeProfile&&data.profiles[data.activeProfile]){
    btProfileSelect.value=data.activeProfile;
    btDelayMs=Number(data.profiles[data.activeProfile].delayMs)||0;
  }else{
    btDelayMs=0;
  }
  btDelayDisplay.textContent=btDelayMs;
  btDelayDebug.textContent=btDelayMs;
}

btProfileSelect.addEventListener('change',()=>{
  const data=loadBTProfiles();
  const name=btProfileSelect.value;
  if(name&&data.profiles[name]){
    btDelayMs=Number(data.profiles[name].delayMs)||0;
    data.activeProfile=name;
  }else{
    btDelayMs=0;
    data.activeProfile='';
  }
  try{localStorage.setItem(BT_PROFILES_KEY,JSON.stringify(data));}catch(e){}
  btDelayDisplay.textContent=btDelayMs;
  btDelayDebug.textContent=btDelayMs;
});

refreshBTProfileUI();

// --- Global State ---
let currentBase="", pollTimer=null, haveMetadata=false, needInitialSeek=false, lastSeekMs=0, settleUntil=0, syncBusy=false;
let logFrozen=false, wasPlaying=false;
let pendingMsg=null, playAttempting=false;

// --- BT Pre-Start State ---
// When btDelayMs > 0 and user clicks Start, audio plays locally first,
// then FSEQ starts after btDelayMs. This keeps the admin audio btDelayMs
// ahead so BT speaker latency brings it back in sync with lights.
// FPP's own audio/FSEQ sync is unaffected — RPi audio is the master clock.
let btPreStartActive=false;    // true while pre-start in progress (blocks sync stop/pause)
let btPreStartGraceUntil=0;    // timestamp: ignore sync stop messages until this time
let btPreStartAbort=false;     // set by Stop button to cancel pre-start

// --- WebSocket Transport ---
const WS_RECONNECT_MS=2000;
const WS_PING_INTERVAL_MS=1000;
const HTTP_POLL_MS=250;
let ws=null, wsConnected=false, wsPingTimer=null, wsReconnectTimer=null;

// --- Clock Offset Estimation (NTP-style) ---
let clockOffset=0, clockOffsetValid=false;
const RTT_HISTORY_SIZE=5;
const OFFSET_HISTORY_SIZE=8;
const MIN_OFFSET_SAMPLES=3;
let rttHistory=[];
let offsetHistory=[];

// --- Sync State ---
const LEAD_MS=2000;
const SEEK_COOLDOWN_MS=2000;
let awaitingStart=false;
let scheduledStartTarget=0;
let lastCorrectionMs=0;
let logThrottle=0;
let errHistoryAll=[];
let errHistory2s=[];

// --- PLL Constants ---
const CAL_MIN_MS=800;
const Kp_BASE=0.01;
const Kp_SCALE=4;
const MAX_ADJ=0.05;
const DEAD_ZONE_MS=5;
const LOG_SCALE_MS=100;
const HARD_SEEK_S=2.0;
const RATE_EMA=0.05;
const MIN_RATE_CHANGE=0.003;

// --- PLL State Machine ---
const pll={phase:'idle',samples:[],baseRate:1.0,anchorLocalMs:0,anchorFppMs:0,lastRateUpdateMs:0};

// --- Effective Rate Measurement (diagnostic) ---
let effRateWallMs=0, effRateLocalMs=0, lastEffRate=0;

// --- Play-Ahead Latency Compensation ---
const PLAY_LATENCY_KEY='fpp-play-latency';
let playLatencyMs=0;
let playCallWallMs=0;
let playCallAudioPos=0;
try{
  const saved=localStorage.getItem(PLAY_LATENCY_KEY);
  if(saved){const v=Number(saved);if(v>=0&&v<1000)playLatencyMs=v;}
}catch(e){}

// --- Utilities ---
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

function pllReset(){
  pll.phase='idle';pll.samples=[];pll.baseRate=1.0;pll.anchorLocalMs=0;pll.anchorFppMs=0;pll.lastRateUpdateMs=0;
  if(audio)audio.playbackRate=1.0;
}

function linearSlope(samples){
  if(samples.length<2)return 1.0;
  const n=samples.length,first=samples[0];
  let sumX=0,sumY=0,sumXX=0,sumXY=0;
  for(let i=0;i<n;i++){
    const x=samples[i].localMs-first.localMs;
    const y=samples[i].fppMs-first.fppMs;
    sumX+=x;sumY+=y;sumXX+=x*x;sumXY+=x*y;
  }
  const denom=n*sumXX-sumX*sumX;
  if(Math.abs(denom)<1e-9)return 1.0;
  return(n*sumXY-sumX*sumY)/denom;
}

// --- Client-Side Log ---
const logBox=document.getElementById('logBox');
const LOG_MAX=200;
let logCount=0;
const logCheck=document.getElementById('logCheck');
function log(msg){
  if(!logCheck.checked||logFrozen)return;
  const t=new Date();
  const ts=t.toTimeString().slice(0,8)+'.'+String(t.getMilliseconds()).padStart(3,'0');
  const line=ts+' '+msg+'\n';
  logBox.textContent+=line;
  logCount++;
  if(logCount>LOG_MAX){
    const lines=logBox.textContent.split('\n');
    logBox.textContent=lines.slice(-LOG_MAX).join('\n');
    logCount=LOG_MAX;
  }
  logBox.scrollTop=logBox.scrollHeight;
}

// --- Server-Side Reporting ---
const REPORT_INTERVAL_MS=1000;
let lastReportMs=0;
let lastRawPosMs=0, lastTargetMs=0, lastLocalMs=0;
let lastAvg2s=0;
const serverLogCheck=document.getElementById('serverLogCheck');
function sendReport(event,errMs,rate){
  if(!serverLogCheck.checked)return;
  if(!ws||ws.readyState!==WebSocket.OPEN)return;
  const now=Date.now();
  const immediate=event==='START'||event==='CORRECTION'||event==='TRACK'||event==='INITIAL_SEEK'||event==='STOP';
  if(!immediate&&(now-lastReportMs)<REPORT_INTERVAL_MS)return;
  lastReportMs=now;
  ws.send(JSON.stringify({
    type:'report',
    event:event,
    fpp:Math.round(lastRawPosMs),
    target:Math.round(lastTargetMs),
    local:Math.round(lastLocalMs),
    err:Math.round(errMs||0),
    rate:Number((rate||1.0).toFixed(4)),
    eff:Number((lastEffRate||0).toFixed(3)),
    offset:Math.round(clockOffset),
    avg2s:Math.round(lastAvg2s),
    track:currentBase||''
  }));
}

// --- Debug UI Controls ---
const logControls=document.getElementById('logControls');
debugCheck.addEventListener('change',()=>{
  debugBox.classList.toggle('hidden',!debugCheck.checked);
});
logCheck.addEventListener('change',()=>{
  const show=logCheck.checked;
  logBox.classList.toggle('hidden',!show);
  logControls.classList.toggle('hidden',!show);
});
document.getElementById('copyLogBtn').onclick=()=>{
  if(navigator.clipboard){navigator.clipboard.writeText(logBox.textContent).then(()=>{document.getElementById('copyLogBtn').textContent='Copied!';setTimeout(()=>{document.getElementById('copyLogBtn').textContent='Copy Log';},1500);});}
};
document.getElementById('clearLogBtn').onclick=()=>{logBox.textContent='';logCount=0;logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';};
document.getElementById('resumeLogBtn').onclick=()=>{logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';log('--- LOG RESUMED ---');};
audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;log('METADATA loaded');});
audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";log('AUDIO ERROR');});

// =============================================================================
// CLOCK OFFSET ESTIMATION
// =============================================================================
function updateClockOffset(serverTs, clientSendTs, rtt){
  const sample=serverTs-clientSendTs-(rtt/2);
  offsetHistory.push(sample);
  if(offsetHistory.length>OFFSET_HISTORY_SIZE)offsetHistory.shift();
  const sorted=[...offsetHistory].sort((a,b)=>a-b);
  const median=sorted[Math.floor(sorted.length/2)];
  if(!clockOffsetValid){
    clockOffset=median;
    clockOffsetValid=true;
  }else{
    clockOffset=clockOffset*0.7+median*0.3;
  }
  offsetEl.textContent=Math.round(clockOffset);
  // Check for large clock mismatch (Pi clock wrong after reboot, no RTC/NTP)
  checkClockMismatch();
}

// =============================================================================
// CLOCK MISMATCH DETECTION (Pi has no RTC, loses time on reboot)
// =============================================================================
let clockWarnShown=false, clockWarnDismissed=false;
function checkClockMismatch(){
  if(clockWarnDismissed||clockWarnShown||!clockOffsetValid)return;
  if(offsetHistory.length<MIN_OFFSET_SAMPLES)return;
  const absOff=Math.abs(clockOffset);
  if(absOff<60000)return; // less than 1 minute - fine
  clockWarnShown=true;
  const offSec=Math.abs(clockOffset)/1000;
  let desc;
  if(offSec>86400){
    const days=Math.round(offSec/86400);
    desc=days+' day'+(days!==1?'s':'');
  }else if(offSec>3600){
    const hrs=Math.round(offSec/3600);
    desc=hrs+' hour'+(hrs!==1?'s':'');
  }else{
    const mins=Math.round(offSec/60);
    desc=mins+' minute'+(mins!==1?'s':'');
  }
  document.getElementById('clockWarnMsg').textContent=
    'Pi clock is off by ~'+desc+'. Set it from your phone?';
  document.getElementById('clockWarn').classList.remove('hidden');
}
document.getElementById('clockYes').onclick=function(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'set_clock',client_ms:Date.now()}));
    document.getElementById('clockWarnMsg').textContent='Setting clock...';
    document.getElementById('clockYes').disabled=true;
    document.getElementById('clockNo').disabled=true;
  }
};
document.getElementById('clockNo').onclick=function(){
  clockWarnDismissed=true;
  document.getElementById('clockWarn').classList.add('hidden');
};

// =============================================================================
// WEBSOCKET CONNECTION (primary transport)
// =============================================================================
function connectWebSocket(){
  if(ws&&(ws.readyState===WebSocket.CONNECTING||ws.readyState===WebSocket.OPEN))return;
  const wsUrl='ws://'+location.hostname+'/ws';
  try{ws=new WebSocket(wsUrl);}catch(e){startHttpFallback();return;}

  ws.onopen=()=>{
    wsConnected=true;
    stopHttpPolling();
    offsetHistory=[];
    clockOffsetValid=false;
    clockOffset=0;
    pollEl.textContent='WebSocket connected';
    fetchErrEl.textContent='';
    // Burst 5 rapid pings for fast clock calibration
    sendPing();
    setTimeout(sendPing,200);
    setTimeout(sendPing,400);
    setTimeout(sendPing,600);
    setTimeout(sendPing,800);
    if(wsPingTimer)clearInterval(wsPingTimer);
    wsPingTimer=setInterval(sendPing,WS_PING_INTERVAL_MS);
    log('WS CONNECTED, burst clock cal');
  };

  ws.onmessage=(event)=>{
    try{
      const data=JSON.parse(event.data);
      if(data.type==='pong'){
        handlePong(data);
      }else if(data.type==='clock_set'){
        const el=document.getElementById('clockWarn');
        if(data.success){
          document.getElementById('clockWarnMsg').textContent='Clock set! Recalibrating...';
          // Reset clock offset estimation with new server time
          offsetHistory=[];
          clockOffsetValid=false;
          clockOffset=0;
          clockWarnShown=false;
          sendPing();setTimeout(sendPing,200);setTimeout(sendPing,400);
          setTimeout(()=>{el.classList.add('hidden');},2000);
        }else{
          document.getElementById('clockWarnMsg').textContent='Failed to set clock.';
          document.getElementById('clockWarnMsg').style.color='var(--bad)';
        }
      }else if(data.state!==undefined){
        sync(data);
      }
    }catch(e){}
  };

  ws.onclose=()=>{
    log('WS DISCONNECTED, falling back to HTTP');
    wsConnected=false;
    if(wsPingTimer){clearInterval(wsPingTimer);wsPingTimer=null;}
    pollEl.textContent='WS disconnected, HTTP fallback';
    startHttpFallback();
    if(wsReconnectTimer)clearTimeout(wsReconnectTimer);
    wsReconnectTimer=setTimeout(connectWebSocket,WS_RECONNECT_MS);
  };

  ws.onerror=()=>{};
}

function sendPing(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'ping',client_ts:Date.now()}));
  }
}

function handlePong(data){
  const now=Date.now();
  const clientTs=data.client_ts;
  const serverTs=data.server_ts;
  const rtt=now-clientTs;
  if(rtt>0&&rtt<500){
    rttHistory.push(rtt);
    if(rttHistory.length>RTT_HISTORY_SIZE)rttHistory.shift();
    rttEl.textContent=rtt;
    updateClockOffset(serverTs,clientTs,rtt);
    log('PONG rtt='+rtt+'ms offset='+Math.round(clockOffset)+'ms');
  }else{
    log('PONG REJECTED rtt='+rtt+'ms (out of range)');
  }
}

// =============================================================================
// HTTP FALLBACK POLLING
// =============================================================================
function startHttpFallback(){
  if(pollTimer)return;
  pollTimer=setInterval(pollOnce,HTTP_POLL_MS);
  pollOnce();
}

function stopHttpPolling(){
  if(pollTimer){clearInterval(pollTimer);pollTimer=null;}
}

async function pollOnce(){
  const t0=Date.now();
  try{
    const url=location.origin+'/listen/status.php?ts='+Date.now();
    const r=await fetch(url,{cache:'no-store'});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const msg=await r.json();
    const t1=Date.now();
    const rtt=t1-t0;
    if(!wsConnected)pollEl.textContent='HTTP ok ('+rtt+' ms)';
    fetchErrEl.textContent='';
    if(msg.server_ms&&rtt>0&&rtt<500){
      updateClockOffset(msg.server_ms,t0,rtt);
      if(!wsConnected)rttEl.textContent=rtt;
    }
    sync(msg);
  }catch(e){
    if(!wsConnected)pollEl.textContent='HTTP FAILED';
    fetchErrEl.textContent='Fetch error: '+(e?.message||e);
  }
}

// =============================================================================
// AUDIO PLAYBACK HELPERS
// =============================================================================
let audioUnlocked=false;

async function safePlay(){
  try{
    const p=audio.play();
    if(p&&typeof p.catch==='function'){await p;}
    playErrEl.textContent='';
  }catch(e){
    if(e&&e.name==='NotAllowedError'){
      // Show the Enable button again so the user knows they need to tap
      if(!audioUnlocked){enableBtn.classList.remove('hidden');}
    }else{
      playErrEl.textContent='Audio error: '+(e?.message||e);
    }
  }
}

// =============================================================================
// AUDIO UNLOCK
// =============================================================================
// Enable Audio button satisfies browser autoplay policy.
// Polling and state detection run regardless - this only gates audio playback.
function unlockAudio(){
  if(audioUnlocked)return;
  audioUnlocked=true;
  enableBtn.classList.add('hidden');
  playErrEl.textContent='';
  // If audio already has a source and is paused (sync tried but was blocked), play it now
  if(audio.src&&audio.paused&&currentBase){
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
    return;
  }
  // Otherwise warm up the audio context with a silent play/pause
  try{
    audio.muted=true;
    const p=audio.play();
    if(p&&typeof p.then==='function'){
      p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;})
      .catch(()=>{audio.muted=false;});
    }else{audio.muted=false;}
  }catch(e){audio.muted=false;}
}
enableBtn.onclick=unlockAudio;

// Start transports immediately on page load
pollEl.textContent='Connecting...';
connectWebSocket();
startHttpFallback();

document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='visible'&&!wsConnected){
    connectWebSocket();
  }
});

// =============================================================================
// SYNC ALGORITHM
// =============================================================================
async function sync(msg){
  pendingMsg=msg;
  if(syncBusy)return;
  syncBusy=true;
  try{
    while(pendingMsg){
      const m=pendingMsg;
      pendingMsg=null;
      await syncInner(m);
    }
  }finally{syncBusy=false;}
}

async function syncInner(msg){
  // Update debug display
  seqEl.textContent=msg.base||'-';
  stateEl.textContent=msg.state||'-';
  targetEl.textContent=msg.pos_ms??'-';

  // Show/hide idle vs playing indicators
  if(msg.state==='stop'||!msg.base){
    idleMsg.classList.remove('hidden');
    nowPlaying.classList.add('hidden');
    playErrEl.textContent='';
  }else{
    idleMsg.classList.add('hidden');
    nowPlaying.classList.remove('hidden');
    trackName.textContent=msg.base+'.fseq';
    if(msg.mp3_url){
      mediaFileEl.textContent=decodeURIComponent(msg.mp3_url.split('/').pop());
    }else{
      mediaFileEl.textContent='No audio file found';
    }
  }

  // --- Track Change ---
  // Skip track change if BT pre-start already loaded this track
  if(msg.base&&msg.base!==currentBase){
    if(btPreStartActive){
      // Pre-start is in progress and WS just started broadcasting the new track.
      // Don't reload audio — we already have it loaded and playing ahead.
      log('BT PRE-START: skipping track change for '+msg.base+' (already loaded)');
    }else{
      logBox.textContent='';logCount=0;logFrozen=false;
      document.getElementById('logStatus').textContent='';
      document.getElementById('resumeLogBtn').style.display='none';
      log('TRACK CHANGE: '+msg.base+' src='+msg.mp3_url);
      sendReport('TRACK',0,1.0);
      currentBase=msg.base;
      haveMetadata=false;
      needInitialSeek=true;
      awaitingStart=false;
      audio.playbackRate=1.0;
      audio.src=msg.mp3_url||'';
      audio.load();
      pllReset();
      errHistoryAll=[];errHistory2s=[];
      effRateWallMs=0;
    }
  }

  // --- Stop State ---
  // During BT pre-start (or brief grace period after FSEQ start command),
  // ignore stop messages — FPP hasn't started yet or WS hasn't detected it.
  if(msg.state==='stop'){
    if(btPreStartActive||Date.now()<btPreStartGraceUntil){
      return;
    }
    if(wasPlaying){
      log('STATE: stop');
      sendReport('STOP',0,1.0);
      if(logCheck.checked){
        logFrozen=true;
        document.getElementById('logStatus').textContent='Log frozen (song ended)';
        document.getElementById('resumeLogBtn').style.display='';
      }
    }
    audio.pause();
    audio.currentTime=0;
    audio.playbackRate=1.0;
    pllReset();
    errHistoryAll=[];errHistory2s=[];
    needInitialSeek=false;
    awaitingStart=false;
    wasPlaying=false;
    return;
  }

  // --- Pause State ---
  if(msg.state==='pause'){
    if(btPreStartActive||Date.now()<btPreStartGraceUntil){
      return;
    }
    log('STATE: pause');
    audio.pause();
    audio.playbackRate=1.0;
    pllReset();
    errHistoryAll=[];errHistory2s=[];
    needInitialSeek=false;
    awaitingStart=false;
    return;
  }

  // --- Playing ---
  wasPlaying=true;

  // Target position calculation
  const nowMs=Date.now();
  const serverMs=Number(msg.server_ms);
  const rawPosMs=Number(msg.pos_ms||0);

  let targetMs=rawPosMs;
  // Use clock offset for serverOk check when available (Pi may have wrong clock - no RTC/NTP)
  const timeDiff=clockOffsetValid?Math.abs((nowMs+clockOffset)-serverMs):Math.abs(nowMs-serverMs);
  const serverOk=Number.isFinite(serverMs)&&serverMs>1e12&&timeDiff<300000;
  if(serverOk){
    let elapsed;
    if(clockOffsetValid){
      elapsed=(nowMs+clockOffset)-serverMs;
    }else{
      elapsed=nowMs-serverMs;
    }
    if(!Number.isFinite(elapsed))elapsed=0;
    // Discard hopelessly stale messages; use real elapsed for accurate targeting
    if(elapsed>2000){return;}
    if(elapsed<0)elapsed=0;
    targetMs=rawPosMs+elapsed+btDelayMs;
  }else{
    log('SERVER_MS INVALID: '+serverMs+' nowMs='+nowMs+' diff='+Math.abs(nowMs-serverMs));
  }

  const targetSec=targetMs/1000.0;
  const localSec=audio.currentTime||0;
  const errMs=(targetSec-localSec)*1000.0;

  lastRawPosMs=rawPosMs;
  lastTargetMs=targetMs;
  lastLocalMs=localSec*1000;

  localEl.textContent=Math.round(localSec*1000);
  targetEl.textContent=Math.round(targetMs);

  if(lastCorrectionMs>0){
    const ago=Math.round((nowMs-lastCorrectionMs)/1000);
    lastCorrectionEl.textContent=ago+'s ago';
  }
  playLatencyEl.textContent=Math.round(playLatencyMs);
  btDelayDebug.textContent=btDelayMs;

  // Gate: wait for clock offset calibration
  if(offsetHistory.length<MIN_OFFSET_SAMPLES){
    errEl.textContent='(clock cal '+offsetHistory.length+'/'+MIN_OFFSET_SAMPLES+')';
    if(++logThrottle%10===0)log('CLOCK CAL: '+offsetHistory.length+'/'+MIN_OFFSET_SAMPLES+' offset samples');
    return;
  }

  // Immediate start
  if(needInitialSeek&&haveMetadata){
    needInitialSeek=false;
    audio.currentTime=clamp(targetSec,0,Math.max(0,audio.duration-0.1));
    log('PLAY NOW: seek to '+Math.round(targetSec*1000)+'ms, PLL will converge after settle');
    sendReport('INITIAL_SEEK',errMs,1.0);
    settleUntil=nowMs+1500;
    effRateWallMs=nowMs;
    effRateLocalMs=targetSec*1000;
    playCallWallMs=Date.now();
    playCallAudioPos=audio.currentTime;
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
    sendReport('START',0,1.0);
    return;
  }

  if(needInitialSeek){
    return;
  }

  // Settle period (1.5s)
  if(nowMs<settleUntil){
    if(playCallWallMs>0&&audio.currentTime!==playCallAudioPos){
      const measuredMs=Date.now()-playCallWallMs;
      playLatencyMs=playLatencyMs>0?(playLatencyMs*0.5+measuredMs*0.5):measuredMs;
      playLatencyMs=clamp(playLatencyMs,0,500);
      log('PLAY_LATENCY measured='+measuredMs+'ms estimate='+Math.round(playLatencyMs)+'ms');
      try{localStorage.setItem(PLAY_LATENCY_KEY,Math.round(playLatencyMs).toString());}catch(e){}
      playCallWallMs=0;
    }
    const sLocalMs=performance.now();
    const sFppMs=targetMs;
    if(pll.phase==='idle'){
      pll.phase='calibrating';
      pll.samples=[{localMs:sLocalMs,fppMs:sFppMs}];
      pllStateEl.textContent='calibrating';
      log('PLL: calibrating during settle');
    }else if(pll.phase==='calibrating'){
      pll.samples.push({localMs:sLocalMs,fppMs:sFppMs});
      pllStateEl.textContent='cal '+pll.samples.length;
    }
    errEl.textContent='(settling)';
    if(++logThrottle%10===0)log('SETTLE remaining='+(settleUntil-nowMs)+'ms samples='+pll.samples.length);
    return;
  }

  // Resume if paused
  if(audio.paused&&!playAttempting){
    log('PLAY resuming (was paused)');
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
  }

  // Normal PLL operation
  errEl.textContent=Math.round(errMs);

  // Error history
  errHistoryAll.push(errMs);
  if(errHistoryAll.length>100)errHistoryAll.shift();
  const avgAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;
  avgErrAllEl.textContent=Math.round(avgAll);

  // 2-second rolling average (PLL error input)
  errHistory2s.push({t:nowMs,err:errMs});
  while(errHistory2s.length>0&&(nowMs-errHistory2s[0].t)>2000)errHistory2s.shift();
  const avg2s=errHistory2s.length>0?(errHistory2s.reduce((a,b)=>a+b.err,0)/errHistory2s.length):0;
  lastAvg2s=avg2s;
  avgErr2sEl.textContent=Math.round(avg2s);

  // Buffered data
  let bufferedSec=0;
  if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}
  bufferedEl.textContent=bufferedSec.toFixed(1);

  if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
    return;
  }

  // Effective rate measurement (diagnostic)
  if(effRateWallMs>0){
    const dWall=nowMs-effRateWallMs;
    const dLocal=(localSec*1000)-effRateLocalMs;
    if(dWall>1000){
      lastEffRate=dLocal/dWall;
      effRateEl.textContent=lastEffRate.toFixed(4);
      effRateWallMs=nowMs;
      effRateLocalMs=localSec*1000;
    }
  }else{
    effRateWallMs=nowMs;
    effRateLocalMs=localSec*1000;
  }

  const localMs=performance.now();
  const fppMs=targetMs;

  // PLL Phase 1: Idle -> Calibrating
  if(pll.phase==='idle'){
    pll.phase='calibrating';
    pll.samples=[{localMs,fppMs}];
    audio.playbackRate=1.0;
    pllStateEl.textContent='calibrating';
    pllRateEl.textContent='1.000';
    log('PLL: calibrating (need '+CAL_MIN_MS+'ms window)');
    sendReport('SYNC',errMs,1.0);
    return;
  }

  // PLL Phase 2: Calibrating
  if(pll.phase==='calibrating'){
    pll.samples.push({localMs,fppMs});
    const calSpanMs=pll.samples.length>1?(pll.samples[pll.samples.length-1].localMs-pll.samples[0].localMs):0;
    pllStateEl.textContent='cal '+Math.round(calSpanMs)+'ms';
    pllRateEl.textContent='1.000';
    errEl.textContent=Math.round(errMs)+' (cal)';

    if(calSpanMs>=CAL_MIN_MS&&pll.samples.length>=6){
      pll.baseRate=linearSlope(pll.samples);
      if(pll.baseRate<0.99||pll.baseRate>1.01)pll.baseRate=1.0;
      pll.phase='locked';
      pll.anchorLocalMs=localMs;
      pll.anchorFppMs=fppMs;
      audio.playbackRate=pll.baseRate;
      pllStateEl.textContent='locked';
      log('PLL: locked baseRate='+pll.baseRate.toFixed(4)+' err='+Math.round(errMs)+'ms from '+pll.samples.length+' samples over '+Math.round(calSpanMs)+'ms');
    }
    sendReport('SYNC',errMs,audio.playbackRate);
    return;
  }

  // PLL Phase 3: Locked
  const phaseErr=targetSec-localSec;
  pllStateEl.textContent='locked';

  // Hard seek if error > 2s
  if(Math.abs(phaseErr)>HARD_SEEK_S&&(nowMs-lastSeekMs)>SEEK_COOLDOWN_MS){
    log('PLL: HARD SEEK err='+Math.round(phaseErr*1000)+'ms (staying locked)');
    sendReport('CORRECTION',phaseErr*1000,audio.playbackRate);
    audio.currentTime=clamp(targetSec,0,Math.max(0,audio.duration-0.1));
    lastSeekMs=nowMs;
    lastCorrectionMs=nowMs;
    pll.anchorLocalMs=localMs;
    pll.anchorFppMs=fppMs;
    errHistoryAll=[];errHistory2s=[];
    if(audio.paused&&!playAttempting){
      playAttempting=true;
      safePlay().finally(()=>{playAttempting=false;});
    }
    return;
  }

  // Adaptive proportional controller with log-compressed correction
  const absAvg2s=Math.abs(lastAvg2s);
  const Kp=Kp_BASE*(1+Kp_SCALE*Math.min(absAvg2s/200,1));
  const rateInterval=absAvg2s>50?500:1000;
  pllStateEl.textContent='locked Kp='+Kp.toFixed(3);

  if((nowMs-pll.lastRateUpdateMs)>=rateInterval){
    pll.lastRateUpdateMs=nowMs;
    let rate=pll.baseRate;
    if(absAvg2s>DEAD_ZONE_MS){
      rate=pll.baseRate+Math.sign(lastAvg2s)*Kp*Math.log1p((absAvg2s-DEAD_ZONE_MS)/LOG_SCALE_MS);
    }
    rate=clamp(rate,1-MAX_ADJ,1+MAX_ADJ);
    if(Math.abs(rate-audio.playbackRate)>MIN_RATE_CHANGE){
      audio.playbackRate=rate;
    }
  }
  pllRateEl.textContent=audio.playbackRate.toFixed(3);

  // Rate learning
  const dtLocal=localMs-pll.anchorLocalMs;
  if(dtLocal>2000){
    const dtFpp=fppMs-pll.anchorFppMs;
    const instRate=dtFpp/dtLocal;
    if(instRate>0.95&&instRate<1.05){
      pll.baseRate=pll.baseRate*(1-RATE_EMA)+instRate*RATE_EMA;
    }
    pll.anchorLocalMs=localMs;
    pll.anchorFppMs=fppMs;
  }

  sendReport('SYNC',errMs,audio.playbackRate);
  if(++logThrottle%20===0)log('PLL err='+Math.round(phaseErr*1000)+'ms rate='+audio.playbackRate.toFixed(3)+'x base='+pll.baseRate.toFixed(4));
}

// Fetch version
fetch("./version.php?t=" + Date.now()).then(r => r.json()).then(v => {
  const verText = "SBS Audio Sync v" + (v.sbs || "?") + " | FPP v" + (v.fpp || "?");
  document.getElementById("ver").textContent = verText;
  document.getElementById("verFooter").textContent = verText;
}).catch(() => { document.getElementById("ver").textContent = "Version: unknown"; });

// ====== Admin: Playback Controls ======
function showStatus(el, msg, ok){
  el.textContent = msg;
  el.className = "status-msg " + (ok ? "success" : "error");
  el.style.display = "block";
  setTimeout(() => { el.style.display = "none"; }, 5000);
}

async function adminPost(data){
  const fd = new FormData();
  for(const k in data) fd.append(k, data[k]);
  const r = await fetch("./admin.php", { method: "POST", body: fd });
  return await r.json();
}

const seqSelect = document.getElementById("seqSelect");
const startSeqBtn = document.getElementById("startSeq");
const stopSeqBtn = document.getElementById("stopSeq");
const seqStatus = document.getElementById("seqStatus");

// Load playlists + sequences on page load
(async function loadSequences(){
  try {
    const res = await adminPost({ action: "get_sequences" });
    if(!res.success) return;
    seqSelect.innerHTML = '<option value="">-- Select --</option>';
    if(Array.isArray(res.playlists) && res.playlists.length > 0){
      const grp = document.createElement("optgroup");
      grp.label = "Playlists";
      res.playlists.forEach(s => {
        const o = document.createElement("option");
        o.value = s; o.textContent = s;
        grp.appendChild(o);
      });
      seqSelect.appendChild(grp);
    }
    if(Array.isArray(res.sequences) && res.sequences.length > 0){
      const grp = document.createElement("optgroup");
      grp.label = "Sequences";
      res.sequences.forEach(s => {
        const o = document.createElement("option");
        o.value = s; o.textContent = s;
        grp.appendChild(o);
      });
      seqSelect.appendChild(grp);
    }
  } catch(e){ seqSelect.innerHTML = '<option value="">Failed to load</option>'; }
})();

startSeqBtn.addEventListener("click", async () => {
  const seq = seqSelect.value;
  if(!seq){ showStatus(seqStatus, "Select a playlist or sequence first", false); return; }
  // User tapped Start - this is a gesture, so unlock audio now
  unlockAudio();
  startSeqBtn.disabled = true;

  const baseName = seq.replace(/\.fseq$/i, '');

  // BT Pre-Start: if BT delay is active AND we can resolve the audio file,
  // play audio locally first, wait btDelayMs, then start the FSEQ on FPP.
  // This puts the admin audio btDelayMs ahead so BT speaker latency compensates.
  if(btDelayMs > 0){
    try {
      const audioRes = await adminPost({ action: "get_audio_url", base: baseName });
      if(audioRes.success && audioRes.url){
        await btPreStart(seq, baseName, audioRes.url);
        startSeqBtn.disabled = false; startSeqBtn.textContent = "Start";
        return;
      }
    } catch(e){}
    // Audio URL lookup failed (playlist, or no matching audio) — fall through to normal start
    log('BT PRE-START: no audio file found for "'+baseName+'", using normal start');
  }

  // Normal start (no BT delay, or audio lookup failed)
  startSeqBtn.textContent = "Starting...";
  try {
    const res = await adminPost({ action: "start_sequence", sequence: seq });
    showStatus(seqStatus, res.success ? "Started: " + seq : (res.error || "Failed"), res.success);
  } catch(e){ showStatus(seqStatus, "Network error", false); }
  startSeqBtn.disabled = false; startSeqBtn.textContent = "Start";
});

// BT Pre-Start: play audio locally, wait btDelayMs, then start FSEQ
async function btPreStart(seq, baseName, audioUrl){
  btPreStartActive = true;
  btPreStartAbort = false;

  try {
    // Set currentBase early so sync() won't trigger a track change reload
    // when the WS server starts broadcasting this sequence
    currentBase = baseName;
    haveMetadata = false;
    needInitialSeek = false;
    audio.playbackRate = 1.0;
    audio.src = audioUrl;
    audio.load();

    startSeqBtn.textContent = "Loading audio...";
    log('BT PRE-START: loading '+audioUrl+' (delay='+btDelayMs+'ms)');

    // Wait for audio metadata
    await new Promise((resolve, reject) => {
      if(haveMetadata){ resolve(); return; }
      const onMeta = () => { audio.removeEventListener('loadedmetadata', onMeta); audio.removeEventListener('error', onErr); resolve(); };
      const onErr  = () => { audio.removeEventListener('loadedmetadata', onMeta); audio.removeEventListener('error', onErr); reject(new Error('Audio load failed')); };
      audio.addEventListener('loadedmetadata', onMeta);
      audio.addEventListener('error', onErr);
    });
    haveMetadata = true;

    if(btPreStartAbort){ throw new Error('Aborted'); }

    // Start playing at position 0
    audio.currentTime = 0;
    startSeqBtn.textContent = "Pre-start (" + btDelayMs + "ms)...";
    log('BT PRE-START: playing audio, FSEQ starts in '+btDelayMs+'ms');

    playAttempting = true;
    await safePlay();
    playAttempting = false;

    // Wait btDelayMs — audio plays ahead while we wait
    await new Promise(r => setTimeout(r, btDelayMs));

    if(btPreStartAbort){ throw new Error('Aborted'); }

    // Initialize PLL state for near-zero error when sync ticks arrive
    pllReset();
    errHistoryAll = []; errHistory2s = [];
    settleUntil = Date.now() + 1500;
    effRateWallMs = Date.now();
    effRateLocalMs = audio.currentTime * 1000;
    wasPlaying = true;

    // Now start the FSEQ on FPP
    startSeqBtn.textContent = "Starting FSEQ...";
    log('BT PRE-START: sending FSEQ start command (audio at '+Math.round(audio.currentTime*1000)+'ms)');

    // Release sync guard with a grace period — WS might still broadcast
    // "stop" for up to ~200ms until the next poll detects FPP is playing
    btPreStartActive = false;
    btPreStartGraceUntil = Date.now() + 500;

    const res = await adminPost({ action: "start_sequence", sequence: seq });
    showStatus(seqStatus, res.success ? "Started: " + seq + " (BT pre-start)" : (res.error || "Failed"), res.success);
    sendReport('START', 0, 1.0);

  } catch(e) {
    btPreStartActive = false;
    btPreStartGraceUntil = 0;
    if(e.message === 'Aborted'){
      log('BT PRE-START: aborted by user');
      showStatus(seqStatus, "Pre-start cancelled", false);
    } else {
      log('BT PRE-START: failed — '+e.message);
      showStatus(seqStatus, "Pre-start failed: " + (e.message || e), false);
    }
    audio.pause();
    audio.currentTime = 0;
    audio.playbackRate = 1.0;
    currentBase = '';
    needInitialSeek = false;
    pllReset();
  }
}

stopSeqBtn.addEventListener("click", async () => {
  // If BT pre-start is in progress, abort it
  if(btPreStartActive){
    btPreStartAbort = true;
    btPreStartActive = false;
    btPreStartGraceUntil = 0;
    audio.pause();
    audio.currentTime = 0;
    audio.playbackRate = 1.0;
    currentBase = '';
    pllReset();
    log('BT PRE-START: stop requested, aborting');
  }
  stopSeqBtn.disabled = true; stopSeqBtn.textContent = "Stopping...";
  try {
    const res = await adminPost({ action: "stop_playback" });
    showStatus(seqStatus, res.success ? "Stopped" : (res.error || "Failed"), res.success);
  } catch(e){ showStatus(seqStatus, "Network error", false); }
  stopSeqBtn.disabled = false; stopSeqBtn.textContent = "Stop";
});


})();
</script>
</body>
</html>
