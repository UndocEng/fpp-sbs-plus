<!doctype html>

<html>

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Listen</title>

  <style>

    body { font-family: system-ui, sans-serif; margin: 0; padding: 18px; background: #111; color: #eee; }

    .header { text-align: center; margin-bottom: 16px; }

    .header img { width: 80px; height: 80px; }

    .header h2 { margin: 8px 0 4px 0; color: #00e5ff; font-size: 36px; font-weight: 700; }

    .small { opacity: .7; font-size: 14px; }

    button { font-size: 22px; padding: 14px 18px; width: 100%; border: 2px solid #00e5ff; border-radius: 10px; background: #222; color: #00e5ff; cursor: pointer; }

    button:disabled { opacity: 0.5; cursor: default; }

    .idle-msg { text-align: center; margin-top: 24px; padding: 20px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; color: #888; font-size: 16px; }

    .now-playing { text-align: center; margin-top: 16px; padding: 14px; border: 1px solid #00e5ff; border-radius: 10px; background: #0a1a1f; font-size: 18px; color: #00e5ff; }

    .debug-toggle { margin-top: 16px; font-size: 13px; opacity: 0.5; }

    .debug-toggle label { cursor: pointer; }

    .box { margin-top: 8px; padding: 12px; border: 1px solid #333; border-radius: 10px; background: #1a1a1a; font-size: 13px; color: #aaa; }

    .box b { color: #ccc; }

    .err { color: #f44; font-weight: 600; }

    .hidden { display: none; }

  </style>

</head>

<body>

  <div class="header">

    <img src="logo-public.png" alt="Undocumented Engineer" />

    <h2>Show Audio</h2>

    <p class="small" style="font-size: 11px; opacity: 0.6; margin-top: -4px;" id="version">v...</p>

    <p class="small">Tap once to enable audio. Keep this page open during the show.</p>

  </div>

  <button id="enableBtn">Enable Audio</button>

  <div id="idleMsg" class="idle-msg">No show is currently broadcasting.</div>

  <div id="nowPlaying" class="now-playing hidden">&#9835; Now Playing: <span id="trackName">-</span></div>

  <div class="err" id="fetchErr"></div>

  <div class="err" id="playErr"></div>

  <div class="debug-toggle"><label><input type="checkbox" id="debugCheck" /> Debug</label> &nbsp; <label><input type="checkbox" id="logCheck" /> Client Log</label> &nbsp; <label><input type="checkbox" id="serverLogCheck" /> Server Log</label></div>

  <div id="debugBox" class="box hidden">

    <div><b>Transport:</b> <span id="transport">-</span></div>

    <div><b>RTT:</b> <span id="rtt">-</span> ms</div>

    <div><b>Clock Offset:</b> <span id="offset">-</span> ms</div>

    <div><b>Sequence:</b> <span id="seq">-</span></div>

    <div><b>State:</b> <span id="state">-</span></div>

    <div><b>Target:</b> <span id="target">-</span> ms</div>

    <div><b>Local:</b> <span id="local">-</span> ms</div>

    <div><b>Error:</b> <span id="err">-</span> ms</div>

    <div><b>PLL State:</b> <span id="pllState">idle</span></div>

    <div><b>Rate:</b> <span id="pllRate">1.000</span>x</div>

    <div><b>Avg Error (2s):</b> <span id="avgErr2s">-</span> ms</div>

    <div><b>Avg Error (all):</b> <span id="avgErrAll">-</span> ms</div>

    <div><b>Effective Rate:</b> <span id="effRate">-</span></div>

    <div><b>Buffered:</b> <span id="buffered">-</span> s</div>

    <div><b>Last Correction:</b> <span id="lastCorrection">-</span></div>

    <div><b>Play Latency:</b> <span id="playLatency">0</span> ms</div>

  </div>

  <div id="logControls" class="hidden" style="margin-top:8px;text-align:right;">
    <span id="logStatus" style="font-size:11px;color:#f90;margin-right:8px;"></span>
    <button id="resumeLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;display:none;">Resume Log</button>
    <button id="copyLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Copy Log</button>
    <button id="clearLogBtn" style="font-size:12px;padding:4px 10px;width:auto;border:1px solid #555;background:#222;color:#aaa;">Clear Log</button>
  </div>
  <div id="logBox" class="box hidden" style="max-height:200px;overflow-y:auto;font-family:monospace;font-size:11px;white-space:pre-wrap;"></div>

  <audio id="audio" preload="auto" playsinline></audio>

<script>

// =============================================================================
// FPP LISTENER SYNC CLIENT — Adaptive PLL Audio Synchronization
// =============================================================================
//
// WHAT THIS DOES:
//   This script synchronizes HTML5 audio playback on audience phones to a
//   Falcon Player (FPP) master clock running on a Raspberry Pi. The Pi runs
//   a light show (sequences + music), and this page plays the same audio
//   track in sync so audience members hear it through their phone speakers
//   or earbuds.
//
// HOW IT WORKS (high level):
//   1. TRANSPORT: A WebSocket connection (preferred) or HTTP polling (fallback)
//      receives the current FPP playback state every ~100ms from the server.
//      Each message contains: state (play/stop/pause), track name, position
//      in milliseconds, and a server timestamp for clock offset calculation.
//
//   2. CLOCK SYNC: NTP-style ping/pong measures round-trip time (RTT) between
//      the phone and Pi. From RTT we estimate a clock offset so we know the
//      exact relationship between the phone's Date.now() and the Pi's clock.
//      This offset is critical because the FPP position timestamp was captured
//      on the Pi — we need to know "how stale is this position?" in phone time.
//
//   3. TARGET CALCULATION: For each incoming message, we compute targetMs —
//      where the audio *should* be right now — by taking the FPP position and
//      adding elapsed time since the Pi captured it (compensated by clock offset).
//
//   4. IMMEDIATE START: When a new track begins, we seek directly to the target
//      position and call play(). No waiting — the PLL will converge from there.
//
//   5. PLL SYNC (Phase-Locked Loop):
//      After a short settle period, we enter a 3-phase PLL:
//        a) CALIBRATE: Collect (localMs, fppMs) sample pairs for 800ms+,
//           compute a least-squares regression slope → baseRate. This tells
//           us the native clock relationship (usually ~1.0000).
//        b) LOCK: Use an adaptive proportional controller to adjust
//           audio.playbackRate. The error input is a 2-second rolling average
//           (avg2s), not instantaneous error, to avoid oscillation. Gain
//           scales up when error is large, scales down when close.
//        c) LEARN: Slowly update baseRate from ongoing observations so the
//           PLL adapts to any clock drift over time.
//
//   6. HARD SEEK: If error ever exceeds 2 seconds (e.g., phone was backgrounded),
//      we do a hard seek + re-calibrate rather than trying to slew back slowly.
//
// WHY A PLL?
//   Simple "check every 5 seconds and seek if off" causes audible glitches
//   because MP3 seeking has ~500ms keyframe granularity. The PLL smoothly
//   adjusts playback speed by tiny amounts (±0.1–5%), which is inaudible
//   and converges to <25ms error in 12-14 seconds.
//
// =============================================================================

// --- DOM References ---
// All UI elements used by the debug display and status indicators
const enableBtn=document.getElementById('enableBtn'),
audio=document.getElementById('audio'),
idleMsg=document.getElementById('idleMsg'),
nowPlaying=document.getElementById('nowPlaying'),
trackName=document.getElementById('trackName'),
pollEl=document.getElementById('transport'),
fetchErrEl=document.getElementById('fetchErr'),
playErrEl=document.getElementById('playErr'),
seqEl=document.getElementById('seq'),
stateEl=document.getElementById('state'),
targetEl=document.getElementById('target'),
localEl=document.getElementById('local'),
errEl=document.getElementById('err'),
pllStateEl=document.getElementById('pllState'),
pllRateEl=document.getElementById('pllRate'),
avgErr2sEl=document.getElementById('avgErr2s'),
avgErrAllEl=document.getElementById('avgErrAll'),
effRateEl=document.getElementById('effRate'),
bufferedEl=document.getElementById('buffered'),
lastCorrectionEl=document.getElementById('lastCorrection'),
playLatencyEl=document.getElementById('playLatency'),
rttEl=document.getElementById('rtt'),
offsetEl=document.getElementById('offset'),
debugCheck=document.getElementById('debugCheck'),
debugBox=document.getElementById('debugBox');

// --- Global State ---
// enabled: user tapped "Enable Audio" (required for mobile autoplay policy)
// currentBase: filename (no extension) of the currently loaded track — used to detect track changes
// haveMetadata: true once the <audio> element has loaded the track's metadata (duration, etc.)
// needInitialSeek: flag set on track change; cleared after the first seek+play
// lastSeekMs: timestamp of last hard seek (for cooldown enforcement)
// settleUntil: timestamp until which we suppress PLL corrections (lets audio stabilize after play/seek)
// syncBusy: reentrance guard — prevents overlapping sync() calls from WebSocket + HTTP simultaneously
let enabled=false, currentBase="", pollTimer=null, haveMetadata=false, needInitialSeek=false, lastSeekMs=0, settleUntil=0, syncBusy=false;
// logFrozen: when a song ends, we freeze the client log so the user can review it
// wasPlaying: tracks play→stop transition to avoid sending STOP reports every 100ms
let logFrozen=false, wasPlaying=false;
// pendingMsg: latest unprocessed message (if sync is busy, we queue the newest and drop older ones)
// playAttempting: guard to prevent multiple simultaneous play() calls
let pendingMsg=null, playAttempting=false;

// --- WebSocket Transport ---
// Primary transport: WebSocket gives us push-based updates at ~100ms from the server.
// Falls back to HTTP polling if WebSocket fails to connect (e.g., proxy issues).
const WS_RECONNECT_MS=2000;       // retry WebSocket connection every 2s after disconnect
const WS_PING_INTERVAL_MS=1000;   // send clock-sync pings every 1s in steady state
const HTTP_POLL_MS=250;            // HTTP fallback polls every 250ms (slower than WS)

let ws=null, wsConnected=false, wsPingTimer=null, wsReconnectTimer=null;

// --- Clock Offset Estimation (NTP-style) ---
// Problem: the server captures pos_ms using the Pi's clock, but we compare it to
// audio.currentTime using the phone's clock. If clocks differ by 200ms, we'd think
// we're 200ms off when we're actually perfectly in sync.
//
// Solution: ping/pong with timestamps. The client sends its Date.now() as client_ts,
// the server echoes it back with server_ts (server's time at receipt). From the
// round-trip time (RTT = now - client_ts), we estimate:
//   offset = server_ts - client_ts - (RTT/2)
// This is the standard NTP single-packet formula assuming symmetric delay.
//
// We keep a sliding window of offset samples, take the median (robust to outliers),
// and smooth with an EWMA (alpha=0.3) for stability.
let clockOffset=0, clockOffsetValid=false;
const RTT_HISTORY_SIZE=5;      // sliding window of recent RTT values (for display)
const OFFSET_HISTORY_SIZE=8;   // sliding window of offset samples for median filter
const MIN_OFFSET_SAMPLES=3;    // require 3+ good offset samples before trusting the offset
let rttHistory=[];
let offsetHistory=[];

// --- Scheduled Start (legacy, partially used) ---
// LEAD_MS: how far ahead to seek when doing a scheduled start (seek ahead, wait, play)
// SEEK_COOLDOWN_MS: minimum time between hard seeks to prevent seek storms
const LEAD_MS=2000;
const SEEK_COOLDOWN_MS=2000;
let awaitingStart=false;         // true while waiting for FPP to catch up to our pre-seeked position
let scheduledStartTarget=0;      // the audio.currentTime we seeked to for a scheduled start
let lastCorrectionMs=0;          // wall time of last hard seek (for debug display "Xs ago")
let logThrottle=0;               // counter to throttle periodic log messages (every Nth tick)
let errHistoryAll=[];            // all error samples since track start (for avgAll display)
let errHistory2s=[];             // timestamped error samples within the last 2 seconds: [{t, err}]

// --- PLL (Phase-Locked Loop) Constants ---
// These control the sync algorithm's behavior. Tuned over many iterations (v2.2.0–v2.2.18).
//
// CAL_MIN_MS: During calibration phase, we need at least this many ms of sample data
//   to compute a reliable least-squares slope for baseRate. Too short → noisy slope.
const CAL_MIN_MS=800;
//
// Kp_BASE / Kp_SCALE: Adaptive proportional gain for the PLL locked phase.
//   When error is small, Kp ≈ Kp_BASE (gentle). When error is large (approaching 200ms),
//   Kp grows up to Kp_BASE * (1 + Kp_SCALE) = 0.05 (aggressive).
//   Formula: Kp = Kp_BASE * (1 + Kp_SCALE * min(|avg2s| / 200, 1))
const Kp_BASE=0.01;
const Kp_SCALE=4;
//
// MAX_ADJ: Hard clamp on playbackRate deviation from 1.0. Prevents extreme speeds
//   that would be audible. ±5% means rate stays in [0.95, 1.05].
const MAX_ADJ=0.05;
//
// DEAD_ZONE_MS: If avg2s error is within ±5ms, don't adjust rate. Prevents micro-jitter
//   corrections that are below the threshold of perception anyway.
const DEAD_ZONE_MS=5;
//
// LOG_SCALE_MS: Denominator for logarithmic compression of the correction signal.
//   rate = baseRate + sign(avg2s) * Kp * log1p((|avg2s| - deadZone) / LOG_SCALE_MS)
//   Higher value = gentler correction curve. 100ms means errors up to ~100ms get
//   proportionally corrected, and larger errors get diminishing additional correction.
const LOG_SCALE_MS=100;
//
// HARD_SEEK_S: If error exceeds this (in seconds), give up on PLL and do a hard seek.
//   This handles cases like the phone being backgrounded for 30+ seconds.
const HARD_SEEK_S=2.0;
//
// RATE_EMA: Exponential moving average alpha for slowly learning the true baseRate
//   during locked phase. 0.05 = very slow adaptation (5% new, 95% old each update).
//   Prevents clock drift from accumulating over minutes.
const RATE_EMA=0.05;
//
// MIN_RATE_CHANGE: Only update audio.playbackRate if the new rate differs from
//   the current rate by at least this much. Prevents unnecessary API calls which
//   can cause micro-stutters on some devices.
const MIN_RATE_CHANGE=0.003;

// --- PLL State Machine ---
// phase: 'idle' → 'calibrating' → 'locked'. Resets to 'idle' on track change/stop.
// samples: array of {localMs, fppMs} during calibration for least-squares regression
// baseRate: the "natural" clock ratio between phone and FPP (usually ~1.0000)
// anchorLocalMs/anchorFppMs: reference point for measuring rate drift in locked phase
// lastRateUpdateMs: when we last adjusted playbackRate (for rate interval throttling)
const pll={phase:'idle',samples:[],baseRate:1.0,anchorLocalMs:0,anchorFppMs:0,lastRateUpdateMs:0};

// --- Effective Rate Measurement (diagnostic only) ---
// Tracks actual audio progression vs wall time to show in debug display.
// Helps verify that playbackRate changes are actually taking effect.
let effRateWallMs=0, effRateLocalMs=0, lastEffRate=0;

// --- Play-Ahead Latency Compensation ---
// Problem: audio.play() doesn't start output instantly. There's a device-specific
// startup delay (buffer fill, codec init). Phones: ~50ms. Desktops: ~200ms.
//
// Solution: Measure the delay on first play (how long until audio.currentTime
// advances after calling play()), smooth it with EWMA (alpha=0.5), persist
// to localStorage so subsequent visits already know this device's latency.
// This latency is used to fire play() that much earlier on scheduled starts.
const PLAY_LATENCY_KEY='fpp-play-latency';
let playLatencyMs=0;       // estimated play() startup latency for this device
let playCallWallMs=0;      // wall time when play() was called (0 = not measuring)
let playCallAudioPos=0;    // audio.currentTime snapshot when play() was called
try{
  // Restore persisted latency estimate from previous session
  const saved=localStorage.getItem(PLAY_LATENCY_KEY);
  if(saved){const v=Number(saved);if(v>=0&&v<1000)playLatencyMs=v;}
}catch(e){}


// --- Utility Functions ---

// Clamp a value between lo and hi (inclusive)
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

// Reset PLL to idle state. Called on track change, stop, pause.
function pllReset(){
  pll.phase='idle';pll.samples=[];pll.baseRate=1.0;pll.anchorLocalMs=0;pll.anchorFppMs=0;pll.lastRateUpdateMs=0;
  if(audio)audio.playbackRate=1.0;
}

// Least-squares linear regression: computes slope of fppMs vs localMs.
// Returns ms of FPP time per ms of local time (i.e., the relative clock speed).
// A slope of 1.0001 means "FPP clock runs 0.01% faster than phone clock."
// We use this during calibration to determine baseRate — the playbackRate that
// would keep the phone exactly in sync if there were no initial offset.
function linearSlope(samples){
  if(samples.length<2)return 1.0;
  const n=samples.length,first=samples[0];
  let sumX=0,sumY=0,sumXX=0,sumXY=0;
  for(let i=0;i<n;i++){
    const x=samples[i].localMs-first.localMs;  // local elapsed since first sample
    const y=samples[i].fppMs-first.fppMs;       // FPP elapsed since first sample
    sumX+=x;sumY+=y;sumXX+=x*x;sumXY+=x*y;
  }
  const denom=n*sumXX-sumX*sumX;
  if(Math.abs(denom)<1e-9)return 1.0;  // degenerate case (all same x)
  return(n*sumXY-sumX*sumY)/denom;
}

// --- Client-Side Log ---
// An on-screen scrollable log for debugging sync behavior on the phone itself.
// Only active when the "Client Log" checkbox is checked. Limited to LOG_MAX lines
// to prevent memory issues on low-end phones during long shows.
const logBox=document.getElementById('logBox');
const LOG_MAX=200;
let logCount=0;
const logCheck=document.getElementById('logCheck');
function log(msg){
  if(!logCheck.checked||logFrozen)return;  // skip if logging disabled or frozen (song ended)
  const t=new Date();
  const ts=t.toTimeString().slice(0,8)+'.'+String(t.getMilliseconds()).padStart(3,'0');
  const line=ts+' '+msg+'\n';
  logBox.textContent+=line;
  logCount++;
  if(logCount>LOG_MAX){
    // Trim to last LOG_MAX lines to prevent unbounded growth
    const lines=logBox.textContent.split('\n');
    logBox.textContent=lines.slice(-LOG_MAX).join('\n');
    logCount=LOG_MAX;
  }
  logBox.scrollTop=logBox.scrollHeight;  // auto-scroll to bottom
}

// --- Server-Side Reporting ---
// Sends sync telemetry back to the Pi via WebSocket, where it's logged to
// /home/fpp/listen-sync/sync.log. Only active when "Server Log" checkbox is
// checked (off by default to minimize overhead — each report is a WS send + disk write).
//
// Events:
//   TRACK          — new track detected
//   INITIAL_SEEK   — first seek after track load
//   START          — play() called
//   SYNC           — periodic heartbeat (throttled to 1/sec)
//   CORRECTION     — hard seek correction
//   STOP           — track ended / FPP stopped
const REPORT_INTERVAL_MS=1000;   // throttle periodic SYNC reports to 1/sec
let lastReportMs=0;
let lastRawPosMs=0, lastTargetMs=0, lastLocalMs=0;  // cached for report payload
let lastAvg2s=0;
const serverLogCheck=document.getElementById('serverLogCheck');
function sendReport(event,errMs,rate){
  if(!serverLogCheck.checked)return;  // user hasn't opted in to server logging
  if(!ws||ws.readyState!==WebSocket.OPEN)return;  // can't report without WS
  const now=Date.now();
  // Important events fire immediately; routine SYNC reports are throttled
  const immediate=event==='START'||event==='CORRECTION'||event==='TRACK'||event==='INITIAL_SEEK'||event==='STOP';
  if(!immediate&&(now-lastReportMs)<REPORT_INTERVAL_MS)return;
  lastReportMs=now;
  ws.send(JSON.stringify({
    type:'report',
    event:event,
    fpp:Math.round(lastRawPosMs),       // raw position from FPP API (ms)
    target:Math.round(lastTargetMs),     // computed target position (ms) — FPP + elapsed
    local:Math.round(lastLocalMs),       // audio.currentTime * 1000 (ms)
    err:Math.round(errMs||0),            // target - local (ms) — positive = behind
    rate:Number((rate||1.0).toFixed(4)), // current playbackRate
    eff:Number((lastEffRate||0).toFixed(3)),  // measured effective rate
    offset:Math.round(clockOffset),      // estimated clock offset (ms)
    avg2s:Math.round(lastAvg2s),         // 2-second rolling average error (ms)
    track:currentBase||''
  }));
}

const logControls=document.getElementById('logControls');
debugCheck.addEventListener('change',()=>{
  debugBox.classList.toggle('hidden',!debugCheck.checked);
});
logCheck.addEventListener('change',()=>{
  const show=logCheck.checked;
  logBox.classList.toggle('hidden',!show);
  logControls.classList.toggle('hidden',!show);
});
document.getElementById('copyLogBtn').onclick=()=>{
  if(navigator.clipboard){navigator.clipboard.writeText(logBox.textContent).then(()=>{document.getElementById('copyLogBtn').textContent='Copied!';setTimeout(()=>{document.getElementById('copyLogBtn').textContent='Copy Log';},1500);});}
};
document.getElementById('clearLogBtn').onclick=()=>{logBox.textContent='';logCount=0;logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';};
document.getElementById('resumeLogBtn').onclick=()=>{logFrozen=false;document.getElementById('logStatus').textContent='';document.getElementById('resumeLogBtn').style.display='none';log('--- LOG RESUMED ---');};
audio.addEventListener('loadedmetadata',()=>{haveMetadata=true;log('METADATA loaded');});
audio.addEventListener('error',()=>{playErrEl.textContent="No matching audio file detected";log('AUDIO ERROR');});

// =============================================================================
// CLOCK OFFSET ESTIMATION
// =============================================================================
// Computes the difference between the phone's clock and the Pi's clock.
//
// NTP formula: offset = serverTs - clientSendTs - (RTT / 2)
//   clientSendTs = phone's Date.now() when it sent the ping
//   serverTs     = Pi's time when it received the ping (from pong response)
//   RTT          = now - clientSendTs (total round trip time)
//   RTT/2        = assumed one-way delay (symmetric assumption)
//
// The offset means: "add this to Date.now() to get the Pi's current time."
// e.g., offset = +50 means the Pi's clock is 50ms ahead of the phone.
//
// Filtering: we keep the last 8 samples, take the median (robust to outliers
// from network jitter), then smooth with EWMA (70% old + 30% new) so the
// offset doesn't jump around from sample to sample.

function updateClockOffset(serverTs, clientSendTs, rtt){
  // Standard NTP single-packet offset estimate
  const sample=serverTs-clientSendTs-(rtt/2);

  // Sliding window of recent offset samples
  offsetHistory.push(sample);
  if(offsetHistory.length>OFFSET_HISTORY_SIZE)offsetHistory.shift();

  // Median filter: robust against outliers (e.g., one ping that got delayed)
  const sorted=[...offsetHistory].sort((a,b)=>a-b);
  const median=sorted[Math.floor(sorted.length/2)];

  if(!clockOffsetValid){
    // First valid estimate — accept it immediately (no prior to smooth against)
    clockOffset=median;
    clockOffsetValid=true;
  }else{
    // EWMA smoothing: 70% prior + 30% new median — prevents jumps
    clockOffset=clockOffset*0.7+median*0.3;
  }
  offsetEl.textContent=Math.round(clockOffset);
}

// =============================================================================
// WEBSOCKET CONNECTION (primary transport)
// =============================================================================
// Connects to ws://<hostname>/ws which Apache proxies to the Python WebSocket
// server on port 8080 (via mod_proxy_wstunnel, configured in apache-listener.conf).
//
// The server pushes FPP state every ~100ms to all connected clients, plus handles
// ping/pong for clock offset and accepts report messages for server-side logging.
//
// On disconnect, we fall back to HTTP polling and attempt to reconnect every 2s.

function connectWebSocket(){
  // Guard: don't open a second connection if one is already active or connecting
  if(ws&&(ws.readyState===WebSocket.CONNECTING||ws.readyState===WebSocket.OPEN))return;
  const wsUrl='ws://'+location.hostname+'/ws';
  try{ws=new WebSocket(wsUrl);}catch(e){startHttpFallback();return;}

  ws.onopen=()=>{
    wsConnected=true;
    stopHttpPolling();  // WS is better than HTTP; stop polling
    // Reset clock offset — the WS connection may be to a different server instance
    // or the network path may have changed. Fresh calibration is safer.
    offsetHistory=[];
    clockOffsetValid=false;
    clockOffset=0;
    pollEl.textContent='WebSocket connected';
    fetchErrEl.textContent='';
    // Burst 5 rapid pings at 200ms intervals for fast initial clock calibration.
    // We want MIN_OFFSET_SAMPLES (3) good samples ASAP so sync can start.
    // Steady-state pings at 1/sec maintain the offset estimate over time.
    sendPing();
    setTimeout(sendPing,200);
    setTimeout(sendPing,400);
    setTimeout(sendPing,600);
    setTimeout(sendPing,800);
    if(wsPingTimer)clearInterval(wsPingTimer);
    wsPingTimer=setInterval(sendPing,WS_PING_INTERVAL_MS);
    log('WS CONNECTED, burst clock cal');
  };

  ws.onmessage=(event)=>{
    try{
      const data=JSON.parse(event.data);
      if(data.type==='pong'){
        // Clock sync response — update offset estimate
        handlePong(data);
      }else if(data.state!==undefined){
        // FPP state broadcast — run sync algorithm
        sync(data);
      }
    }catch(e){}
  };

  ws.onclose=()=>{
    log('WS DISCONNECTED, falling back to HTTP');
    wsConnected=false;
    if(wsPingTimer){clearInterval(wsPingTimer);wsPingTimer=null;}
    pollEl.textContent='WS disconnected, HTTP fallback';
    startHttpFallback();  // switch to HTTP polling immediately
    // Schedule a reconnect attempt — WS will take over again on success
    if(wsReconnectTimer)clearTimeout(wsReconnectTimer);
    wsReconnectTimer=setTimeout(connectWebSocket,WS_RECONNECT_MS);
  };

  ws.onerror=()=>{};  // onclose will fire after onerror; handled there
}

// Send a clock-sync ping. The server echoes client_ts back plus its own server_ts.
function sendPing(){
  if(ws&&ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({type:'ping',client_ts:Date.now()}));
  }
}

// Process a pong (clock-sync response from server).
// Reject samples with extreme RTT (>500ms) — they'd give a bad offset estimate.
function handlePong(data){
  const now=Date.now();
  const clientTs=data.client_ts;   // our original timestamp, echoed back
  const serverTs=data.server_ts;   // server's timestamp at receipt
  const rtt=now-clientTs;          // total round-trip time

  if(rtt>0&&rtt<500){
    rttHistory.push(rtt);
    if(rttHistory.length>RTT_HISTORY_SIZE)rttHistory.shift();
    rttEl.textContent=rtt;
    updateClockOffset(serverTs,clientTs,rtt);
    log('PONG rtt='+rtt+'ms offset='+Math.round(clockOffset)+'ms');
  }else{
    // RTT too high — network was congested, skip this sample
    log('PONG REJECTED rtt='+rtt+'ms (out of range)');
  }
}

// =============================================================================
// HTTP FALLBACK POLLING
// =============================================================================
// When WebSocket is unavailable (e.g., proxy not configured, connection lost),
// we fall back to polling status.php every 250ms. This is slower and higher
// overhead than WS (each poll = full HTTP request/response), but still works.
//
// status.php calls the FPP API server-side and returns the same JSON format
// as the WebSocket broadcast, plus server_ms timestamps for clock offset.

function startHttpFallback(){
  if(pollTimer)return;  // already polling
  pollTimer=setInterval(pollOnce,HTTP_POLL_MS);
  pollOnce();  // fire immediately, don't wait for first interval
}

function stopHttpPolling(){
  if(pollTimer){clearInterval(pollTimer);pollTimer=null;}
}

async function pollOnce(){
  if(!enabled)return;
  const t0=Date.now();
  try{
    // Cache-bust with timestamp param to prevent stale responses
    const url=location.origin+'/listen/status.php?ts='+Date.now();
    const r=await fetch(url,{cache:'no-store'});
    if(!r.ok)throw new Error('HTTP '+r.status);
    const msg=await r.json();
    const t1=Date.now();
    const rtt=t1-t0;  // HTTP round-trip time (includes PHP execution + FPP API call)
    if(!wsConnected)pollEl.textContent='HTTP ok ('+rtt+' ms)';
    fetchErrEl.textContent='';

    // Use HTTP timing for clock offset estimation (same math as WS pong)
    // server_ms is the midpoint of the FPP API call on the Pi
    if(msg.server_ms&&rtt>0&&rtt<500){
      updateClockOffset(msg.server_ms,t0,rtt);
      if(!wsConnected)rttEl.textContent=rtt;
    }

    // Feed the state to the sync algorithm (same path as WS messages)
    sync(msg);
  }catch(e){
    if(!wsConnected)pollEl.textContent='HTTP FAILED';
    fetchErrEl.textContent='Fetch error: '+(e?.message||e);
  }
}

// =============================================================================
// AUDIO PLAYBACK HELPERS
// =============================================================================

// Safely call audio.play() — wraps the promise to catch autoplay rejections.
// Mobile browsers block play() unless it originates from a user gesture (tap).
// That's why we require the "Enable Audio" button tap first.
async function safePlay(){
  try{
    const p=audio.play();
    if(p&&typeof p.catch==='function'){await p;}
    playErrEl.textContent='';
  }catch(e){
    playErrEl.textContent='Audio playback blocked: '+(e?.message||e);
  }
}

// =============================================================================
// ENABLE BUTTON (user gesture to unlock audio)
// =============================================================================
// Mobile browsers (iOS Safari, Chrome) require a user tap to unlock the
// AudioContext and allow play(). This button serves that purpose.
// On tap: (1) start WebSocket + HTTP connections, (2) do a muted play/pause
// cycle to "warm up" the audio element so future play() calls succeed.

enableBtn.onclick=()=>{
  enabled=true;
  enableBtn.disabled=true;
  enableBtn.textContent='Audio Enabled';
  pollEl.textContent='Connecting...';

  // Start both transports — WS will shut down HTTP polling if it connects
  connectWebSocket();
  startHttpFallback();

  // Audio unlock gesture: play muted, then immediately pause.
  // This satisfies the browser's autoplay policy so future play() calls
  // (triggered by sync, not by user tap) will be allowed.
  try{
    audio.muted=true;
    const p=audio.play();
    if(p&&typeof p.then==='function'){
      p.then(()=>{audio.pause();audio.currentTime=0;audio.muted=false;})
      .catch(()=>{audio.muted=false;});
    }else{audio.muted=false;}
  }catch(e){audio.muted=false;}
};

// When the user switches back to this tab/app, try to reconnect WS if needed.
// Mobile phones often kill WS connections when the browser is backgrounded.
document.addEventListener('visibilitychange',()=>{
  if(document.visibilityState==='visible'&&enabled&&!wsConnected){
    connectWebSocket();
  }
});

// === Scheduled Start Helper (legacy, used for future scheduled-start mode) ===
// Seeks ahead of the current FPP position by LEAD_MS, pauses, and waits for FPP
// to catch up. When FPP reaches the seeked position, play() is fired at the
// precise moment. This avoids MP3 keyframe seek inaccuracy during live playback
// because the seek happens while paused (before audio starts).

function beginScheduledStart(targetSec){
  const leadSec=LEAD_MS/1000;
  const seekTo=clamp(targetSec+leadSec,0,audio.duration-0.05);
  audio.pause();
  audio.currentTime=seekTo;

  const onSeeked=()=>{
    audio.removeEventListener('seeked',onSeeked);
    // Note: audio.currentTime may differ from seekTo due to MP3 keyframe snapping
    scheduledStartTarget=audio.currentTime;
    awaitingStart=true;
    log('SCHEDULED seek landed='+Math.round(scheduledStartTarget*1000)+'ms (target was '+Math.round(seekTo*1000)+'ms)');
  };
  audio.addEventListener('seeked',onSeeked);
}

// =============================================================================
// SYNC ALGORITHM — The core of the system
// =============================================================================
//
// Called every time we receive a state update from the server (~100ms via WS,
// ~250ms via HTTP). Each call computes where the audio *should* be, compares
// to where it actually is, and applies corrections via the PLL.
//
// Architecture: sync() is a reentrance guard that queues messages. If multiple
// messages arrive while we're processing one (e.g., WS push while HTTP response
// is being handled), we only process the *latest* one and drop stale ones.
// This prevents a backlog from building up during slow processing.

async function sync(msg){
  pendingMsg=msg;  // always keep the latest message
  if(syncBusy)return;  // another sync is running; it will pick up pendingMsg
  syncBusy=true;
  try{
    // Process messages until none are pending. This loop handles the case
    // where a new message arrives during syncInner() processing.
    while(pendingMsg){
      const m=pendingMsg;
      pendingMsg=null;
      await syncInner(m);
    }
  }finally{syncBusy=false;}
}

async function syncInner(msg){
  // --- Update debug display with raw values ---
  seqEl.textContent=msg.base||'-';
  stateEl.textContent=msg.state||'-';
  targetEl.textContent=msg.pos_ms??'-';

  // --- UI: show/hide "no show broadcasting" vs "now playing" ---
  if(msg.state==='stop'||!msg.base){
    idleMsg.classList.remove('hidden');
    nowPlaying.classList.add('hidden');
    playErrEl.textContent='';
  }else{
    idleMsg.classList.add('hidden');
    nowPlaying.classList.remove('hidden');
    trackName.textContent=msg.base;
  }

  // --- Track Change Detection ---
  // When the FPP starts playing a different file, we need to load the new
  // audio file, reset the PLL, and prepare for a fresh sync.
  if(msg.base&&msg.base!==currentBase){
    logBox.textContent='';logCount=0;logFrozen=false;
    document.getElementById('logStatus').textContent='';
    document.getElementById('resumeLogBtn').style.display='none';
    log('TRACK CHANGE: '+msg.base+' src='+msg.mp3_url);
    sendReport('TRACK',0,1.0);
    currentBase=msg.base;
    haveMetadata=false;      // wait for loadedmetadata event on new file
    needInitialSeek=true;    // will seek to FPP position on first sync tick
    awaitingStart=false;
    audio.playbackRate=1.0;
    audio.src=msg.mp3_url||'';  // mp3_url is like "/music/song.mp3"
    audio.load();               // start loading the new file
    pllReset();
    errHistoryAll=[];errHistory2s=[];
    effRateWallMs=0;
  }

  // --- Stop State ---
  // FPP has stopped playing. Pause local audio, reset all sync state.
  // Only report STOP once (wasPlaying guard) to avoid flooding the server
  // with STOP events every 100ms while FPP is idle.
  if(msg.state==='stop'){
    if(wasPlaying){
      log('STATE: stop');
      sendReport('STOP',0,1.0);
      // Freeze the client log so user can review the just-finished song's data
      if(logCheck.checked){
        logFrozen=true;
        document.getElementById('logStatus').textContent='Log frozen (song ended)';
        document.getElementById('resumeLogBtn').style.display='';
      }
    }
    audio.pause();
    audio.currentTime=0;
    audio.playbackRate=1.0;
    pllReset();
    errHistoryAll=[];errHistory2s=[];
    needInitialSeek=false;
    awaitingStart=false;
    wasPlaying=false;
    return;
  }

  // --- Pause State ---
  // FPP is paused. Pause local audio, reset PLL (will re-calibrate on resume).
  if(msg.state==='pause'){
    log('STATE: pause');
    audio.pause();
    audio.playbackRate=1.0;
    pllReset();
    errHistoryAll=[];errHistory2s=[];
    needInitialSeek=false;
    awaitingStart=false;
    return;
  }

  // --- Playing State (remainder of function) ---
  wasPlaying=true;

  // =========================================================================
  // TARGET POSITION CALCULATION
  // =========================================================================
  // The server told us "FPP was at pos_ms at server_ms (server time)."
  // But some time has passed since then (network delay + processing).
  // We need to compute: "where is FPP *right now*?"
  //
  // Formula: targetMs = pos_ms + elapsed
  //   where elapsed = (phone_now + clockOffset) - server_ms
  //
  // (phone_now + clockOffset) converts phone time to server time,
  // then subtracting server_ms gives us how many ms have passed since
  // the server captured pos_ms. We clamp elapsed to [0, 300] to reject
  // nonsense values (negative = future, >300ms = stale/unreliable).
  const nowMs=Date.now();
  const serverMs=Number(msg.server_ms);
  const rawPosMs=Number(msg.pos_ms||0);

  let targetMs=rawPosMs;
  // Sanity check: server_ms should be a Unix timestamp (>1e12) and within 5min of now
  const serverOk=Number.isFinite(serverMs)&&serverMs>1e12&&Math.abs(nowMs-serverMs)<300000;
  if(serverOk){
    let elapsed;
    if(clockOffsetValid){
      // Offset-corrected: convert phone time to server time, find delta
      elapsed=(nowMs+clockOffset)-serverMs;
    }else{
      // No offset yet — assume clocks are close enough (best effort)
      elapsed=nowMs-serverMs;
    }
    if(!Number.isFinite(elapsed))elapsed=0;
    elapsed=clamp(elapsed,0,300);  // 0–300ms is a reasonable transit time
    targetMs=rawPosMs+elapsed;
  }else{
    log('SERVER_MS INVALID: '+serverMs+' nowMs='+nowMs+' diff='+Math.abs(nowMs-serverMs));
  }

  // Convert to seconds for comparison with audio.currentTime
  const targetSec=targetMs/1000.0;
  const localSec=audio.currentTime||0;
  // Error: positive = phone is behind FPP (needs to speed up / seek forward)
  //        negative = phone is ahead of FPP (needs to slow down)
  const errMs=(targetSec-localSec)*1000.0;

  // Cache for server-side reporting
  lastRawPosMs=rawPosMs;
  lastTargetMs=targetMs;
  lastLocalMs=localSec*1000;

  // Update debug display
  localEl.textContent=Math.round(localSec*1000);
  targetEl.textContent=Math.round(targetMs);

  if(lastCorrectionMs>0){
    const ago=Math.round((nowMs-lastCorrectionMs)/1000);
    lastCorrectionEl.textContent=ago+'s ago';
  }
  playLatencyEl.textContent=Math.round(playLatencyMs);

  // =========================================================================
  // GATE: Wait for clock offset calibration
  // =========================================================================
  // We can't sync accurately until we have a confident clock offset estimate.
  // Without it, our target calculation could be off by hundreds of ms.
  // The burst pings on WS connect get us 3+ samples within ~800ms.
  if(offsetHistory.length<MIN_OFFSET_SAMPLES){
    errEl.textContent='(clock cal '+offsetHistory.length+'/'+MIN_OFFSET_SAMPLES+')';
    if(++logThrottle%10===0)log('CLOCK CAL: '+offsetHistory.length+'/'+MIN_OFFSET_SAMPLES+' offset samples');
    return;
  }

  // =========================================================================
  // IMMEDIATE START — First sync tick after track loads
  // =========================================================================
  // Strategy: seek directly to where FPP is now and press play immediately.
  // The PLL will converge from whatever initial error this produces.
  //
  // Why not scheduled start? Scheduled start (seek ahead, wait, play at the
  // right moment) avoids MP3 keyframe seek error, but adds 2+ seconds of
  // silence before audio begins. Immediate start gets audio playing instantly
  // and the PLL smoothly corrects the ~500ms keyframe error within 12-14 seconds.
  if(needInitialSeek&&haveMetadata){
    needInitialSeek=false;
    audio.currentTime=clamp(targetSec,0,Math.max(0,audio.duration-0.1));
    log('PLAY NOW: seek to '+Math.round(targetSec*1000)+'ms, PLL will converge after settle');
    sendReport('INITIAL_SEEK',errMs,1.0);
    // 1.5-second settle period: no PLL corrections during this time.
    // The audio element needs time to stabilize after seek + play.
    // During settle, we collect calibration samples for the PLL.
    settleUntil=nowMs+1500;
    // Reset effective rate measurement anchor
    effRateWallMs=nowMs;
    effRateLocalMs=targetSec*1000;
    // Start measuring play() startup latency for this device
    playCallWallMs=Date.now();
    playCallAudioPos=audio.currentTime;
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
    sendReport('START',0,1.0);
    return;
  }

  if(needInitialSeek){
    // Audio file is still loading (waiting for loadedmetadata event).
    // Can't seek until we know the duration.
    return;
  }

  // =========================================================================
  // SETTLE PERIOD (1.5 seconds after play starts)
  // =========================================================================
  // During settle, we do two things simultaneously:
  //   1. Measure play() startup latency (how long until audio.currentTime moves)
  //   2. Collect PLL calibration samples (localMs, fppMs pairs for regression)
  //
  // No rate corrections happen during settle — the audio is stabilizing and
  // the error measurements would be noisy. When settle ends, the PLL has
  // enough samples to compute baseRate and can transition to locked immediately.
  if(nowMs<settleUntil){
    // --- Play latency measurement ---
    // After calling play(), watch for audio.currentTime to change from its
    // initial value. The delay between play() call and first currentTime
    // movement is the play() startup latency for this device.
    if(playCallWallMs>0&&audio.currentTime!==playCallAudioPos){
      const measuredMs=Date.now()-playCallWallMs;
      // EWMA smoothing: 50% old + 50% new (or accept first measurement as-is)
      playLatencyMs=playLatencyMs>0?(playLatencyMs*0.5+measuredMs*0.5):measuredMs;
      playLatencyMs=clamp(playLatencyMs,0,500);  // sanity clamp
      log('PLAY_LATENCY measured='+measuredMs+'ms estimate='+Math.round(playLatencyMs)+'ms');
      try{localStorage.setItem(PLAY_LATENCY_KEY,Math.round(playLatencyMs).toString());}catch(e){}
      playCallWallMs=0;  // done measuring
    }
    // --- PLL calibration sample collection ---
    // Build up (localMs, fppMs) pairs. After settle, linearSlope() will compute
    // the least-squares regression to determine baseRate.
    const sLocalMs=performance.now();
    const sFppMs=targetMs;
    if(pll.phase==='idle'){
      pll.phase='calibrating';
      pll.samples=[{localMs:sLocalMs,fppMs:sFppMs}];
      pllStateEl.textContent='calibrating';
      log('PLL: calibrating during settle');
    }else if(pll.phase==='calibrating'){
      pll.samples.push({localMs:sLocalMs,fppMs:sFppMs});
      pllStateEl.textContent='cal '+pll.samples.length;
    }
    errEl.textContent='(settling)';
    if(++logThrottle%10===0)log('SETTLE remaining='+(settleUntil-nowMs)+'ms samples='+pll.samples.length);
    return;
  }

  // --- Resume playback if browser paused it (e.g., tab switch, lock screen) ---
  if(audio.paused&&!playAttempting){
    log('PLAY resuming (was paused)');
    playAttempting=true;
    safePlay().finally(()=>{playAttempting=false;});
  }

  // =========================================================================
  // NORMAL OPERATION — PLL Sync
  // =========================================================================
  errEl.textContent=Math.round(errMs);

  // --- Error History ---
  // errHistoryAll: running window of last 100 error samples (for avgAll diagnostic)
  errHistoryAll.push(errMs);
  if(errHistoryAll.length>100)errHistoryAll.shift();
  const avgAll=errHistoryAll.length>0?(errHistoryAll.reduce((a,b)=>a+b,0)/errHistoryAll.length):0;
  avgErrAllEl.textContent=Math.round(avgAll);

  // errHistory2s: time-windowed 2-second rolling average.
  // THIS IS THE PLL'S ERROR INPUT (not instantaneous error).
  // Why avg2s instead of instantaneous?
  //   - Instantaneous error is noisy (±80ms) due to network jitter and
  //     FPP's ~100ms poll interval. Using it directly causes the PLL to
  //     overcorrect and oscillate.
  //   - avg2s is smooth and stable, giving the PLL a clean signal.
  //   - 2 seconds is short enough to track real drift but long enough
  //     to filter out jitter.
  errHistory2s.push({t:nowMs,err:errMs});
  while(errHistory2s.length>0&&(nowMs-errHistory2s[0].t)>2000)errHistory2s.shift();
  const avg2s=errHistory2s.length>0?(errHistory2s.reduce((a,b)=>a+b.err,0)/errHistory2s.length):0;
  lastAvg2s=avg2s;
  avgErr2sEl.textContent=Math.round(avg2s);

  // Buffered data (diagnostic: shows how much audio is pre-buffered)
  let bufferedSec=0;
  if(audio.buffered.length>0){bufferedSec=audio.buffered.end(audio.buffered.length-1)-localSec;}
  bufferedEl.textContent=bufferedSec.toFixed(1);

  // Need metadata (duration) before we can do anything meaningful
  if(!haveMetadata||!Number.isFinite(audio.duration)||audio.duration<=0){
    return;
  }

  // --- Effective Rate Measurement (diagnostic only) ---
  // Compares actual audio progression to wall clock time over 1-second windows.
  // If playbackRate=1.002 but effRate shows 1.000, the browser isn't honoring
  // our rate request (some mobile browsers quantize playbackRate).
  if(effRateWallMs>0){
    const dWall=nowMs-effRateWallMs;
    const dLocal=(localSec*1000)-effRateLocalMs;
    if(dWall>1000){
      lastEffRate=dLocal/dWall;
      effRateEl.textContent=lastEffRate.toFixed(4);
      effRateWallMs=nowMs;
      effRateLocalMs=localSec*1000;
    }
  }else{
    effRateWallMs=nowMs;
    effRateLocalMs=localSec*1000;
  }

  // performance.now() for high-resolution local timestamps (used in PLL)
  const localMs=performance.now();
  const fppMs=targetMs;

  // =========================================================================
  // PLL PHASE 1: IDLE → Start Calibrating
  // =========================================================================
  // First tick after settle ends (or after a re-calibration). Begin collecting
  // (localMs, fppMs) sample pairs for least-squares regression.
  if(pll.phase==='idle'){
    pll.phase='calibrating';
    pll.samples=[{localMs,fppMs}];
    audio.playbackRate=1.0;
    pllStateEl.textContent='calibrating';
    pllRateEl.textContent='1.000';
    log('PLL: calibrating (need '+CAL_MIN_MS+'ms window)');
    sendReport('SYNC',errMs,1.0);
    return;
  }

  // =========================================================================
  // PLL PHASE 2: CALIBRATING — Determine baseRate via least-squares regression
  // =========================================================================
  // Collect samples for at least CAL_MIN_MS (800ms) with at least 6 data points.
  // Then compute the slope of fppMs vs localMs — this tells us the relative
  // clock speed between the phone and FPP. A slope of 1.0002 means "for every
  // 1000ms of phone time, FPP advances 1000.2ms" — the phone needs to play
  // at 1.0002x speed to keep up.
  //
  // The clamp to [0.99, 1.01] rejects garbage slopes that can occur if the
  // sample window overlaps with the settle period's unstable audio output.
  if(pll.phase==='calibrating'){
    pll.samples.push({localMs,fppMs});
    const calSpanMs=pll.samples.length>1?(pll.samples[pll.samples.length-1].localMs-pll.samples[0].localMs):0;
    pllStateEl.textContent='cal '+Math.round(calSpanMs)+'ms';
    pllRateEl.textContent='1.000';
    errEl.textContent=Math.round(errMs)+' (cal)';

    if(calSpanMs>=CAL_MIN_MS&&pll.samples.length>=6){
      pll.baseRate=linearSlope(pll.samples);
      // Clamp: reject slopes beyond ±1%. Real clock drift is typically <0.01%.
      // Bad slopes come from noisy data during the settle→calibrate transition.
      if(pll.baseRate<0.99||pll.baseRate>1.01)pll.baseRate=1.0;
      pll.phase='locked';
      // IMPORTANT: No snap-seek at lock time.
      // We used to seek to the target position here, but MP3 keyframe granularity
      // (~500ms) means the seek would land 250-300ms off, causing overshoot.
      // Instead, we let the adaptive PLL smoothly converge from the current error.
      pll.anchorLocalMs=localMs;
      pll.anchorFppMs=fppMs;
      audio.playbackRate=pll.baseRate;
      pllStateEl.textContent='locked';
      log('PLL: locked baseRate='+pll.baseRate.toFixed(4)+' err='+Math.round(errMs)+'ms from '+pll.samples.length+' samples over '+Math.round(calSpanMs)+'ms');
    }
    sendReport('SYNC',errMs,audio.playbackRate);
    return;
  }

  // =========================================================================
  // PLL PHASE 3: LOCKED — Continuous adaptive rate correction
  // =========================================================================
  // This is where the magic happens. We continuously adjust audio.playbackRate
  // to keep the phone in sync with FPP.
  //
  // The correction signal uses avg2s (2-second rolling average error) as input,
  // not the instantaneous error. This is critical for stability — see note above.
  const phaseErr=targetSec-localSec;
  pllStateEl.textContent='locked';

  // --- Hard Seek: Emergency correction for large errors (>2 seconds) ---
  // If the phone was backgrounded for 30+ seconds, the PLL can't slew back
  // fast enough. Jump directly to the right position and continue.
  // Cooldown prevents seek storms if the error measurement is unstable.
  if(Math.abs(phaseErr)>HARD_SEEK_S&&(nowMs-lastSeekMs)>SEEK_COOLDOWN_MS){
    log('PLL: HARD SEEK err='+Math.round(phaseErr*1000)+'ms (staying locked)');
    sendReport('CORRECTION',phaseErr*1000,audio.playbackRate);
    audio.currentTime=clamp(targetSec,0,Math.max(0,audio.duration-0.1));
    lastSeekMs=nowMs;
    lastCorrectionMs=nowMs;
    // Reset rate learning anchors since we just jumped
    pll.anchorLocalMs=localMs;
    pll.anchorFppMs=fppMs;
    errHistoryAll=[];errHistory2s=[];
    if(audio.paused&&!playAttempting){
      playAttempting=true;
      safePlay().finally(()=>{playAttempting=false;});
    }
    return;
  }

  // --- Adaptive Proportional Controller ---
  //
  // Kp (gain) scales with error magnitude:
  //   Small error (<5ms):   Kp ≈ 0.01 (gentle, no overshoot)
  //   Medium error (~100ms): Kp ≈ 0.03 (moderate correction)
  //   Large error (~200ms+): Kp ≈ 0.05 (aggressive, converge fast)
  //
  // rateInterval controls how often we update playbackRate:
  //   Large error (>50ms): every 500ms (faster convergence)
  //   Small error (<50ms): every 1000ms (less jitter, more stable)
  //
  // The correction is log-compressed:
  //   rate = baseRate + sign(avg2s) * Kp * log1p((|avg2s| - deadZone) / LOG_SCALE)
  //   This gives strong initial correction that tapers off as error shrinks,
  //   preventing overshoot without sacrificing convergence speed.
  const absAvg2s=Math.abs(lastAvg2s);
  const Kp=Kp_BASE*(1+Kp_SCALE*Math.min(absAvg2s/200,1));
  const rateInterval=absAvg2s>50?500:1000;
  pllStateEl.textContent='locked Kp='+Kp.toFixed(3);

  if((nowMs-pll.lastRateUpdateMs)>=rateInterval){
    pll.lastRateUpdateMs=nowMs;
    let rate=pll.baseRate;
    if(absAvg2s>DEAD_ZONE_MS){
      // Outside dead zone: apply log-compressed correction
      rate=pll.baseRate+Math.sign(lastAvg2s)*Kp*Math.log1p((absAvg2s-DEAD_ZONE_MS)/LOG_SCALE_MS);
    }
    // Hard clamp to ±5% — prevents inaudible but technically extreme rates
    rate=clamp(rate,1-MAX_ADJ,1+MAX_ADJ);
    // Only update if change exceeds threshold — avoids unnecessary API calls
    // that can cause micro-stutters on some mobile browsers
    if(Math.abs(rate-audio.playbackRate)>MIN_RATE_CHANGE){
      audio.playbackRate=rate;
    }
  }
  pllRateEl.textContent=audio.playbackRate.toFixed(3);

  // --- Rate Learning: slowly adapt baseRate to track clock drift ---
  // Every 2+ seconds, compute the actual rate of FPP progression vs local time
  // from the anchor points. Blend this into baseRate with a slow EMA (alpha=0.05).
  // This prevents accumulated drift over long songs (10+ minutes) from requiring
  // ever-larger corrections.
  const dtLocal=localMs-pll.anchorLocalMs;
  if(dtLocal>2000){
    const dtFpp=fppMs-pll.anchorFppMs;
    const instRate=dtFpp/dtLocal;
    // Only update if the measured rate is plausible (within ±5%)
    if(instRate>0.95&&instRate<1.05){
      pll.baseRate=pll.baseRate*(1-RATE_EMA)+instRate*RATE_EMA;
    }
    // Reset anchors for next measurement window
    pll.anchorLocalMs=localMs;
    pll.anchorFppMs=fppMs;
  }

  // Periodic server-side reporting
  sendReport('SYNC',errMs,audio.playbackRate);

  // Periodic client-side logging (every 20th tick ≈ every 2 seconds)
  if(++logThrottle%20===0)log('PLL err='+Math.round(phaseErr*1000)+'ms rate='+audio.playbackRate.toFixed(3)+'x base='+pll.baseRate.toFixed(4));
}

// Fetch and display version (cache-busting)
fetch('/listen/version.php?t='+Date.now()).then(r=>r.json()).then(v=>{document.getElementById('version').textContent='v'+(v.eavesdrop||'?')+' | FPP v'+(v.fpp||'?');}).catch(()=>{});

</script>

</body>

</html>
