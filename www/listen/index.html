<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Listen</title>
  <style>
    :root{
      --bg:#0f1115;
      --card:#171a21;
      --ink:#e9eef7;
      --muted:#9aa6b2;
      --accent:#00e5ff;
      --bad:#ff4d4d;
      --ok:#4dff88;
    }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink); }
    .wrap{ max-width:720px; margin:0 auto; padding:18px; }
    .header{ text-align:center; margin:10px 0 18px; }
    .header img{ width:86px; height:86px; border-radius:18px; box-shadow:0 8px 28px rgba(0,0,0,.35); }
    h1{ margin:12px 0 6px; font-size:34px; letter-spacing:.3px; color:var(--accent); }
    .sub{ margin:0; color:var(--muted); font-size:14px; }
    .card{
      background:var(--card); border:1px solid rgba(255,255,255,.06);
      border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    button{
      width:100%; font-size:20px; padding:14px 16px; border-radius:14px;
      border:2px solid var(--accent); background:#11141a; color:var(--ink);
      cursor:pointer;
    }
    button:active{ transform:scale(.99); }
    .row{ display:flex; gap:10px; margin-top:12px; }
    .row button{ width:50%; font-size:16px; padding:12px; border-radius:12px; }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid rgba(255,255,255,.08);
      border-radius:999px; padding:8px 12px; color:var(--muted); font-size:13px;
      background:rgba(0,0,0,.18);
    }
    .dot{ width:10px; height:10px; border-radius:50%; background:#666; }
    .dot.ok{ background:var(--ok); }
    .dot.bad{ background:var(--bad); }
    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    .kv{ background:rgba(0,0,0,.14); border:1px solid rgba(255,255,255,.06); border-radius:12px; padding:10px 12px; }
    .k{ font-size:12px; color:var(--muted); }
    .v{ margin-top:4px; font-size:14px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .small{ margin-top:12px; font-size:12px; color:var(--muted); line-height:1.4; }
    .footer{ margin-top:14px; text-align:center; font-size:12px; color:var(--muted); opacity:.85; }
    audio{ width:100%; margin-top:12px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <img src="logo.png" alt="Undocumented Engineer" />
    <h1>Show Audio</h1>
    <p class="sub">Tap once to enable audio. Keep this page open during the show.</p>
  </div>

  <div class="card">
    <span class="pill"><span id="dot" class="dot"></span><span id="state">Idle</span></span>

    <div style="margin-top:12px;">
      <button id="enable">Enable Audio</button>
      <div class="row">
        <button id="mute">Mute</button>
        <button id="resync">Resync</button>
      </div>
    </div>

    <audio id="player" preload="auto" playsinline></audio>

    <div class="grid">
      <div class="kv"><div class="k">Track</div><div class="v" id="track">&mdash;</div></div>
      <div class="kv"><div class="k">Error</div><div class="v" id="err">&mdash;</div></div>
      <div class="kv"><div class="k">Rate</div><div class="v" id="rate">&mdash;</div></div>
      <div class="kv"><div class="k">Poll</div><div class="v" id="poll">&mdash;</div></div>
    </div>

    <div class="small">
      If audio is silent on iPhone, check the ringer switch and volume.
      You may need to stay on this page (some phones pause background audio).
    </div>

    <div class="footer" id="ver">Version: (loading&hellip;)</div>
  </div>
</div>

<script>
(() => {
  // ====== Config ======
  const STATUS_URL = "./status.php";
  const POLL_MS = 250;
  const HARD_SEEK_S = 1.0;          // seek if error exceeds this (seconds)
  const SEEK_COOLDOWN_MS = 2000;    // don't seek more often than this

  // ====== UI refs ======
  const dot = document.getElementById("dot");
  const stateEl = document.getElementById("state");
  const trackEl = document.getElementById("track");
  const errEl = document.getElementById("err");
  const rateEl = document.getElementById("rate");
  const pollEl = document.getElementById("poll");
  const verEl = document.getElementById("ver");
  const enableBtn = document.getElementById("enable");
  const muteBtn = document.getElementById("mute");
  const resyncBtn = document.getElementById("resync");
  const audio = document.getElementById("player");

  // ====== State ======
  let enabled = false;
  let muted = false;
  let currentBase = "";
  let pollTimer = null;
  let haveMetadata = false;
  let lastSeekMs = 0;

  // Clock offset estimation
  let clockOffset = 0;
  let clockOffsetValid = false;
  const OFFSET_HISTORY_SIZE = 8;
  let offsetHistory = [];

  function setDot(mode){
    dot.classList.remove("ok","bad");
    if(mode==="ok") dot.classList.add("ok");
    if(mode==="bad") dot.classList.add("bad");
  }

  function setState(text, ok){
    stateEl.textContent = text;
    setDot(ok ? "ok" : (ok===false ? "bad" : ""));
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // ====== Clock offset ======
  function updateClockOffset(serverMs, clientSendMs, rtt){
    const sample = serverMs - clientSendMs - (rtt / 2);
    offsetHistory.push(sample);
    if(offsetHistory.length > OFFSET_HISTORY_SIZE) offsetHistory.shift();
    const sorted = [...offsetHistory].sort((a,b) => a - b);
    const median = sorted[Math.floor(sorted.length / 2)];
    if(!clockOffsetValid){
      clockOffset = median;
      clockOffsetValid = true;
    } else {
      clockOffset = clockOffset * 0.7 + median * 0.3;
    }
  }

  // ====== Compute FPP target position in seconds ======
  function getTargetSec(msg){
    const nowMs = Date.now();
    const serverMs = Number(msg.server_ms);
    const rawPosMs = Number(msg.pos_ms || 0);
    let targetMs = rawPosMs;
    if(Number.isFinite(serverMs) && serverMs > 1e12 && Math.abs(nowMs - serverMs) < 300000){
      let elapsed = clockOffsetValid ? ((nowMs + clockOffset) - serverMs) : (nowMs - serverMs);
      if(!Number.isFinite(elapsed)) elapsed = 0;
      elapsed = clamp(elapsed, 0, 1500);
      targetMs = rawPosMs + elapsed;
    }
    return targetMs / 1000.0;
  }

  // ====== Sync ======
  function sync(msg){
    trackEl.textContent = msg.base || "\u2014";

    // --- Stop state: pause and reset ---
    if(msg.state === "stop" || !msg.base){
      if(!audio.paused) audio.pause();
      audio.currentTime = 0;
      audio.playbackRate = 1.0;
      currentBase = "";
      haveMetadata = false;
      setState("Idle", null);
      errEl.textContent = "\u2014";
      rateEl.textContent = "\u2014";
      return;
    }

    // --- Pause state ---
    if(msg.state === "pause"){
      if(!audio.paused) audio.pause();
      audio.playbackRate = 1.0;
      setState("Paused", true);
      return;
    }

    // --- Playing ---
    setState("Playing", true);

    // Track change — load new source
    if(msg.base && msg.base !== currentBase){
      currentBase = msg.base;
      haveMetadata = false;
      audio.src = msg.mp3_url || "";
      audio.load();
      audio.addEventListener("loadedmetadata", function onMeta(){
        audio.removeEventListener("loadedmetadata", onMeta);
        haveMetadata = true;
        // Don't seek with stale msg data — let the next poll tick
        // handle positioning with fresh data (250ms away at most)
      });
      return;
    }

    // Wait for metadata
    if(!haveMetadata || !Number.isFinite(audio.duration) || audio.duration <= 0) return;

    const targetSec = getTargetSec(msg);
    const localSec = audio.currentTime || 0;
    const errSec = targetSec - localSec;

    // Update display
    errEl.textContent = (errSec >= 0 ? "+" : "") + (errSec * 1000).toFixed(0) + " ms";
    rateEl.textContent = audio.playbackRate.toFixed(3) + "x";

    const absErr = Math.abs(errSec);
    const nowMs = Date.now();

    // Hard seek if off by more than 1s (or first sync after load)
    if(absErr > HARD_SEEK_S && (nowMs - lastSeekMs) > SEEK_COOLDOWN_MS){
      audio.currentTime = clamp(targetSec, 0, Math.max(0, audio.duration - 0.1));
      audio.playbackRate = 1.0;
      lastSeekMs = nowMs;
      if(audio.paused) audio.play().catch(() => {});
      return;
    }

    // Ensure playing
    if(audio.paused) audio.play().catch(() => {});

    // Within 1s — play at normal speed. FPP only gives whole-second
    // precision so sub-second error is just quantization noise.
    audio.playbackRate = 1.0;
  }

  // ====== Polling ======
  async function tick(){
    const t0 = Date.now();
    try {
      const r = await fetch(STATUS_URL + "?ts=" + t0, { cache: "no-store" });
      if(!r.ok) throw new Error("HTTP " + r.status);
      const msg = await r.json();
      const t1 = Date.now();
      const rtt = t1 - t0;
      pollEl.textContent = rtt + " ms";

      // Update clock offset
      if(msg.server_ms && rtt > 0 && rtt < 500){
        updateClockOffset(msg.server_ms, t0, rtt);
      }

      if(enabled){
        sync(msg);
      } else {
        // Show current state but don't control audio
        if(msg.state === "play" && msg.base){
          setState("Playing", true);
          trackEl.textContent = msg.base;
        } else {
          setState("Idle", null);
        }
      }
    } catch(e){
      setState("Disconnected", false);
    }
  }

  function startPolling(){
    if(pollTimer) return;
    pollTimer = setInterval(tick, POLL_MS);
    tick();
  }

  // ====== UI events ======
  enableBtn.addEventListener("click", async () => {
    enabled = true;
    enableBtn.textContent = "Audio Enabled";
    setState("Enabled", true);

    // Audio unlock gesture
    try {
      audio.muted = true;
      const p = audio.play();
      if(p && typeof p.then === 'function'){
        await p.then(() => { audio.pause(); audio.currentTime = 0; audio.muted = false; })
               .catch(() => { audio.muted = false; });
      } else {
        audio.muted = false;
      }
    } catch(_){ audio.muted = false; }

    startPolling();
  });

  muteBtn.addEventListener("click", () => {
    muted = !muted;
    muteBtn.textContent = muted ? "Unmute" : "Mute";
    audio.muted = muted;
  });

  resyncBtn.addEventListener("click", () => {
    if(!haveMetadata || !currentBase) return;
    // Force immediate resync on next tick by clearing cooldown
    lastSeekMs = 0;
  });

  // Fetch version
  fetch("./version.php?t=" + Date.now()).then(r => r.text()).then(t => {
    verEl.textContent = "Version: " + (t || "").trim();
  }).catch(() => { verEl.textContent = "Version: unknown"; });

  // Start polling immediately to show status even before enable
  startPolling();
})();
</script>
</body>
</html>
